## CS 스터디 7주차

### 정규화(Nomalization)
* Good Design Principle : "one fact in one place" i.e. "avoid redundancy"
* 정규화(Normalization)은 데이터베이스 설계를 재구성하는 테크닉으로, 데이터 중복을 최소화하고 데이터의 일관성을 유지하기 위한 중요한 과정이다. 이를 통해 다양한 이상현상(Anomalies)을 방지할 수 있으며, 데이터를 "논리적으로" 구성할 수 있다. 

* 정규화의 주요 목적
1. 데이터 중복성 제거: 불필요한 데이터 중복을 없애고, 데이터를 한 번만 저장하여 저장 공간을 절약한다.
2. 이상현상 방지: 삽입, 갱신, 삭제 시 발생할 수 있는 이상현상을 방지한다.
* 정규화 단계를 거치면 데이터베이스의 구조가 최적화되고, 데이터 중복과 이상현상을 최소화하여 데이터베이스를 효율적으로 관리할 수 있다.

* 정규화의 단계
1. 1차 정규화: 각 로우마다 컬럼의 값이 1개씩만 있어야 하며, 컬럼이 원자값을 가져야 한다. 즉, 다중 값 속성을 분리한다.
2. 2차 정규화: 모든 컬럼이 완전 함수적 종속을 만족해야 한다. 부분 함수 종속을 제거한다.
3. 3차 정규화: 이행 함수 종속성을 제거한다.
4. BCNF (Boyce-Codd Normal Form): 모든 결정자가 후보키인 경우로, 3차 정규화에서 해결할 수 없는 이상현상을 해결한다.
5. 4차 정규화: 다중값 종속성을 제거한다.
6. 5차 정규화: 결합 종속성을 제거한다.

### 이상(Anomaly)
* 이상(Anomaly)은 데이터베이스 설계 과정에서 중요한 고려 사항 중 하나로, 정보의 불일치를 방지하기 위해 고려되는 요소 중 하나이다. 이상 현상은 세 가지 주요 유형으로 나눌 수 있으며, 각각 갱신 이상(Modification Anomaly), 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly)로 분류된다. 

* 갱신, 삽입, 삭제 작업을 수행할 때 불일치 및 이상 현상을 방지하려면 테이블 설계를 신중하게 고민하고 데이터베이스를 정규화하여 데이터 중복을 최소화해야 한다. 

**갱신 이상**
* 갱신 이상은 데이터의 불일치를 일으키는 현상 중 하나로, 반복된 데이터 중 일부를 업데이트 할 때 발생한다. 만약 데이터베이스에서 일부 데이터만 갱신하고 나머지는 그대로 둔다면 데이터의 일관성이 깨질 수 있다.

* 갱신 이상의 예시로, 근무자(employee) 테이블을 들어 보자. 이 테이블은 근무자가 속한 부서(Department)와 참여하고 있는 학생 그룹(Student_Group)을 나타낸다. A. Bruchs의 부서가 변경되었다고 가정하자. 에 대한 반복적 데이터가 있을 때, 테이블의 일부 행을 수정하지 않고 다른 부분만 변경하면 A. Bruchs의 부서가 어느 부서에 속한지 알 수 없게 된다.

**삽입 이상**
* 삽입 이상은 데이터를 추가할 때 발생하는 불일치를 나타내며, 불필요한 정보를 함께 저장하지 않으면 원하는 정보를 저장할 수 없는 문제가 발생한다. 이로 인해 데이터베이스에 필요한 정보를 추가하기 위해 불필요한 정보를 함께 입력해야 할 수도 있다.

* 삽입 이상의 경우, 새로운 Engineering 부서를 추가하려면 아직 근무자가 없어도 관련 정보를 입력해야 하는 불편함이 발생할 수 있다.


**삭제 이상**
* 삭제 이상은 데이터 삭제 시 데이터베이스의 일관성을 깨뜨리는 현상으로, 어떤 정보를 삭제할 때 다른 의도하지 않은 정보도 함께 삭제되는 경우 발생한다.

* 삭제 이상의 경우, Accounting 부서에 속한 J. Longfellow 단 한 명만 있다고 가정해보자. J. Longfellow의 정보를 삭제하면 Accounting 부서에 대한 정보도 함께 사라지게 된다.


### 인덱스(INDEX)
* 인덱스는 데이터베이스에서 테이블에 대한 검색 속도를 높여주는 자료구조이다. 데이터베이스의 테이블에서 특정 데이터를 찾는 데 인덱스는 중요한 역할을 한다. 인덱스는 비유적으로 책의 맨 처음 또는 맨 마지막에 있는 색인과 유사하다. 이것은 데이터베이스의 내용을 효율적으로 검색하는 데 도움을 주며 데이터가 저장된 레코드의 주소를 가리키는 역할을 한다.

* 데이터베이스 관리 시스템(DBMS)에서, 데이터를 검색하기 위해 모든 레코드를 스캔하는 것은 시간이 많이 걸린다. 그래서 칼럼의 값을 키로 사용하여 인덱스를 만들어 데이터를 빠르게 찾을 수 있도록 한다. 인덱스는 데이터를 항상 정렬된 상태로 유지하여 검색 속도를 높이지만, 새로운 값을 추가, 삭제 또는 수정할 때는 성능 저하를 가져온다.

* 데이터베이스에서 인덱스의 자료구조는 다양하다. B+-Tree는 칼럼 값을 변형하지 않고 원래 값을 통해 인덱싱하며, 리프 노드에 데이터를 모아두는 특징이 있다. 또한, 리프 노드가 연결 리스트 형태를 띄고 있어 검색 시간을 줄여준다. 하지만 해시 인덱스 알고리즘도 매우 빠른 검색을 지원한다. 그러나 일부 값을 검색할 때는 해시 인덱스를 사용할 수 없다.

* 데이터베이스에서 INDEX를 생성할 때 고려해야 할 점이 있다. 모든 컬럼에 INDEX를 생성하면 빠를 것 같지만, INSERT, DELETE, UPDATE 쿼리 실행 시 추가적인 작업이 필요하고 성능 저하가 발생한다. 또한, 어떤 컬럼을 인덱스로 설정하느냐도 중요하다. 결합 인덱스는 여러 컬럼을 복합적으로 지정하는데, 어떤 순서로 인덱스를 설정하는지에 따라 검색 성능이 달라질 수 있다.

* 요약하면, 인덱스는 데이터베이스에서 데이터를 효율적으로 검색하기 위한 자료구조로, 데이터의 수정과 삭제가 적은 경우나 SELECT와 ORDER BY 연산이 자주 발생하며 데이터의 크기가 큰 경우에 적합하다. 그러나 항상 정렬된 상태를 유지해야 하며, 모든 컬럼에 인덱스를 생성하는 것은 권장되지 않는다.


### 트랜잭션(Transaction)
* 트랜잭션(Transaction)은 데이터베이스 작업의 완전성을 보장하는 중요한 개념이다. 트랜잭션은 논리적인 작업의 묶음으로, 모든 작업이 성공적으로 처리되거나 실패한 경우 원래 상태로 복구하는 역할을 한다. 사용자 관점에서는 작업의 논리적 단위로 이해되며, 시스템 관점에서는 데이터 접근 및 변경을 제어하는 프로그램의 단위가 된다.

* 트랜잭션은 ACID라는 네 가지 특성을 만족해야 한다. 

* 첫째, 원자성(Atomicity)은 트랜잭션이 중간에 실패하면 어떤 작업도 적용되지 않아야 하고, 성공한 경우에만 모든 작업이 적용되어야 한다.

* 둘째, 일관성(Consistency)은 트랜잭션이 완료된 후에도 데이터베이스가 이전 상태와 일관성을 유지해야 한다.

* 셋째, 고립성(Isolation)은 다수의 트랜잭션이 동시에 실행되더라도 서로 간섭없이 독립적으로 실행되어야 한다.

* 마지막으로, 지속성(Durability)은 트랜잭션이 정상적으로 종료된 후에는 작업 결과가 영구적으로 데이터베이스에 저장되어야 한다.

* 트랜잭션의 중요한 연산으로는 'Commit'과 'Rollback'이 있다. 'Commit'은 트랜잭션이 성공적으로 종료될 때 트랜잭션 관리자에게 알리는 작업이며, 'Rollback'은 중간에 오류가 발생하여 트랜잭션을 취소하고 이전 상태로 돌아가는 작업이다.

* 트랜잭션의 상태는 활동상태, 부분 완료, 완료, 실패, 철회 다섯 가지로 나눌 수 있다. 활동 상태는 현재 트랜잭션 실행 중인 상태를 나타내며, 부분 완료는 트랜잭션의 일부 작업이 완료된 상태를 나타낸다. 완료 상태는 트랜잭션이 정상적으로 완료된 상태이고, 실패 상태는 트랜잭션 중에 오류가 발생한 상태를 나타낸다. 마지막으로, 철회 상태는 트랜잭션이 오류를 일으켜서 롤백을 수행한 상태를 의미한다.

* 트랜잭션은 데이터베이스의 무결성과 동시성을 보장하기 위한 중요한 개념으로, ACID 특성을 만족하며 원자성, 일관성, 고립성, 지속성을 가지고 있습니다. 트랜잭션은 작업의 완전성을 보장하고, 'Commit'과 'Rollback'을 통해 관리됩니다. 트랜잭션의 상태는 활동상태, 부분 완료, 완료, 실패, 철회 다섯 가지로 나뉘며, 이러한 특성과 상태를 통해 데이터베이스 작업을 안전하게 수행할 수 있습니다.


### 트랜잭션 격리 수준(Transaction Isolation Level)
* 트랜잭션 격리 수준, 또는 Transaction Isolation Level은 데이터베이스 트랜잭션의 동시성 및 데이터 무결성을 관리하기 위한 중요한 개념이다. 
아래는 세 가지 출처에서 나온 정보를 조합한 자연스러운 텍스트이다. 트랜잭션 격리 수준은 데이터베이스 시스템에서 중요한 역할을 하며, 애플리케이션에서 올바르게 설정하고 관리함으로써 데이터 무결성과 동시성을 유지할 수 있다.

* 트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때, 트랜잭션 간 상호 작용 정도를 조절하는데 사용되며, ACID 원칙을 지키면서도 동시성을 향상시킬 수 있다. 그러나 격리 수준을 너무 높게 설정하면 문제가 발생할 가능성이 커집니다. 이 수준을 결정하는 것은 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있는지 여부를 결정하는 것이다.

1. **READ UNCOMMITTED(미완료 읽기):** 이 격리 수준은 각 트랜잭션이 변경 내용이 COMMIT이나 ROLLBACK 여부에 관계 없이 다른 트랜잭션에서 값을 읽을 수 있게 한다. 그러나 이것은 데이터 무결성 문제가 많이 발생하는 격리 수준이므로 권장되지 않는다. 트랜잭션이 아직 완료되지 않았지만 다른 트랜잭션에서 볼 수 있는 "DIRTY READ(더티 리드)" 현상이 발생할 수 있다.

2. **READ COMMITTED(읽기 커밋):** 이 격리 수준은 RDB에서 주로 사용되며, Dirty Read와 같은 문제가 발생하지 않는다. 트랜잭션에서 변경 내용이 COMMIT된 후에만 다른 트랜잭션에서 조회할 수 있다. 데이터를 가져올 때는 실제 테이블이 아닌 Undo 영역에 백업된 레코드에서 값을 가져온다.

3. **REPEATABLE READ(반복 가능한 읽기):** MySQL에서 사용되며, 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 낮은 트랜잭션 번호에서 변경한 것만 읽을 수 있다. 업데이트 및 삭제는 허용하지 않지만, 삽입은 허용한다. 이로 인해 "PHANTOM READ(유령 읽기)"가 발생할 수 있으며, 이를 방지하기 위해 쓰기 잠금을 사용해야 한다.

4. **SERIALIZABLE(직렬화 가능):** 가장 엄격한 격리 수준으로, 동시 처리 성능이 가장 낮다. 이 수준에서는 PHANTOM READ가 발생하지 않지만, 일반적으로 거의 사용되지 않는다.

* 트랜잭션 경계설정은 다른 트랜잭션과의 독립성을 관리하며, PlatformTransactionManager를 통해 이를 관리할 수 있다. 또한 선언적 트랜잭션과 어노테이션을 사용하여 트랜잭션 경계를 설정할 수 있으며, 이를 통해 트랜잭션의 전파 타입과 격리 수준을 정의할 수 있다.


### Array
* Array는 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 자료구조로, index와 값의 쌍으로 구성되어 있다. Index는 값에 대한 고유한 ID 역할을 하며, Array에서는 원소의 순서를 나타낸다. 배열은 연속된 메모리의 공간으로 이루어져 있어, 연속적인 메모리 공간에 순차적으로 데이터가 나열된다.이러한 배열은 논리적 저장 순서와 물리적 저장 순서가 일치하므로, index를 사용하여 해당 원소에 접근할 수 있다(O(1)). 배열은 정의할 때 길이를 지정하며, 이 길이는 바꿀 수 없다. 

이러한 배열의 장단점은 다음과 같다.

**장점:**
1. 인덱스를 통한 검색이 용이하다.
2. 연속적인 메모리 공간으로 이루어져 있어 메모리 관리가 편하다.
3. Random access에 강하며 시간 복잡도는 O(1)이다.
4. 구현이 비교적 쉽다.
5. 연속적인 메모리 구조로 인해 cache hit이 자주 발생한다.

**단점:**
1. 배열은 선언 이후에 크기가 고정되어 있기 때문에 크기를 늘릴 수 없다.
2. 자료 삽입이나 삭제가 발생할 때 모든 데이터를 옮겨야 하므로 시간 복잡도는 O(n)이다.
3. 사용하지 않는 공간도 할당해야 하므로 메모리 낭비가 발생한다. 또한, 크기를 컴파일 이전에 정해주어야 하며 컴파일 이후에는 배열의 크기를 변경할 수 없다.

### Linked List
* 연결 리스트(Linked List)는 순서가 있는 원소들의 모임이다. 

**특징:**
* 연결 리스트는 불연속적으로 메모리 공간을 차지하며 포인터를 통한 접근을 사용한다. 
* 배열과는 다르게 빈 원소는 허용하지 않는다. (다만, Java와 같은 언어에서 이를 허용하는 경우도 있다.) 
* 동적이기 때문에 크기가 정해져 있지 않다. 

**장점:**
* Linked List는 데이터를 삭제할 때의 시간 복잡도가 1이며, 데이터의 삽입 및 삭제가 용이하며, 동적인 데이터의 추가 및 삭제가 가능하므로, 메모리의 재사용과 메모리 관리를 편리하게 한다는 장점이 있다. 

**단점:**
* 그러나 검색 성능이 좋지 않다는 단점도 존재하며, 포인터를 통해 다음 데이터를 가리키므로 추가적인 메모리 공간을 소비하는 단점이 있다. 
* 연결 리스트는 불연속적 메모리 공간 점유 특성으로 인해 순차성이 보장되지 않으며 공간 접근성이 떨어져 캐시 히트가 어렵다. 


### Array vs ArrayList
* ArrayList와 배열 모두 데이터를 저장하고 관리하는 목적에서 사용되지만, 크기의 동적 조절, 데이터 유형의 제한, 제네릭 지원, 길이 확인 및 데이터 삽입 방식 등에서 차이가 있다.

* 배열은 크기가 고정되어 있으며, 크기를 동적으로 조절할 수 없지만, ArrayList는 사이즈가 동적으로 조절 가능한 배열이다. 이는 배열의 크기가 한 번 설정되면 변경할 수 없지만, ArrayList는 필요에 따라 크기를 조절할 수 있다는 것을 의미한다. 

* 또한, 배열은 primitive type(예: int, byte, char 등)과 object를 모두 담을 수 있지만, ArrayList는 object element만을 담을 수 있다. 다시 말해, ArrayList가 객체만을 처리할 수 있는 반면, 배열은 기본 데이터 유형과 객체 모두를 다룰 수 있다는 점에서 다르다.

* 또한, 배열은 제네릭을 사용할 수 없지만, ArrayList는 타입 안정성을 보장해주는 제네릭을 사용할 수 있다. 다시 말해, ArrayList가 데이터 형식의 안정성을 유지하며 컴파일 시 타입 검사를 수행할 수 있는 데 반해, 배열은 이러한 기능을 제공하지 않는다

* 데이터 길이에 관해서는 배열은 length 변수를 사용하고, ArrayList는 size() 메서드를 사용한다. 따라서 배열의 길이를 얻을 때는 length 변수를 사용하고, ArrayList의 길이를 확인할 때는 size() 메서드를 활용해야 한다. 

* 마지막으로, 배열은 element를 할당하기 위해 assignment(할당) 연산자를 사용하고, ArrayList는 add() 메서드를 통해 element를 한다.


### ArrayList vs LinkedList
* LinkedList는 노드 간에 연결(link)을 통해서 리스트로 구현된 객체이며, ArrayList는 배열과 같이 연속적인 메모리에 저장된다.

* LinkedList는 다음 노드의 위치 정보만 가지고 있으며 인덱스를 가지고 있지 않기 때문에 탐색시 순차접근만 가능하다. 이로 인해 노드를 탐색할 때 많은 시간이 소요될 수 있으며 random access가 불가능하다. 반면에, ArrayList는 인덱스를 이용하여 랜덤 액세스가 가능하다. 따라서, 데이터를 빠르게 찾는 상황에서 ArrayList가 더 효율적이다.

* 또한, LinkedList는 노드의 추가 및 삭제가 위치 정보의 수정만으로 가능하기 때문에 성능이 우수하다. 하지만, ArrayList는 사이즈를 늘려 뒤로 한 칸씩 밀거나 당기는 작업을 해야하기 때문에 성능이 좋지 않다. 이러한 특성으로 인해 데이터의 추가와 삭제가 빈번하게 발생하는 경우 LinkedList가 더 유리하다.

* 물리적 저장 순서와 논리적 저장 순서가 일치하지 않는 점은 LinkedList와 ArrayList의 중요한 차이점 중 하나이다. LinkedList는 원소의 추가와 삭제가 쉬우며, 이로 인해 동적인 데이터 변경에 적합하다. 그러나 원소를 조회하는 속도가 느리다는 단점도 있다.

* LinkedList는 List 인터페이스를 구현한 AbstractList를 상속하지 않고, 대신 AbstractSequentialList를 상속한다. 이것은 LinkedList가 다른 자료 구조와는 다른 상속 구조를 가지고 있음을 나타낸다.


### Hash
* 해시(Hash)는 데이터를 빠르게 검색하기 위한 자료구조 중 하나이다. 해시 테이블은 key, value 쌍 데이터를 저장하는 자료구조로, 해시 함수를 사용하여 키를 해시값으로 매핑하고 이 해시 값을 주소 또는 색인 삼아 데이터(value)를 key와 함께 저장하는 자료구조이다. 입력된 데이터에 해시 함수(Hash Function)를 적용해 얻은 주소로부터 그 위치를 직접 참조하는 방법이다. 데이터가 저장되는 곳을 버킷, 슬롯이라고 한다.

* 해시 함수는 key를 고정된 길이의 hash로 변경해주는 역할을 한다. 탐색, 삽입, 삭제 연산 모두 해시 함수를 거치는 시간만 소요되기 때문에 일반적으로 O(1) 시간 복잡도를 가진다. 

**단점**
* 해시 충돌이 발생할 가능성이 있다. 
* 데이터가 저장되기 전 저장 공간을 미리 만들어야 하며 공간이 만들어진 이후에도 공간을 채우지 않는 경우도 발생한다. 
* 해시 함수에 대한 의존도가 높다. 
* 해시 함수가 복잡하다면 hash를 만드는 데 오래 걸릴 수 있다.

**- 해시 충돌**
* 키가 될 수 있는 값보다 자료의 개수가 많거나, 해시함수를 돌렸으나 해시값이 동일한 경우가 생긴다면 이를 해시 충돌이라고 부른다.

* 해시 충돌을 해결하는 방식에는 크게 Open Addressing Method와 Closed Addressing Method이 있다.

* Open Addressing Method는 충돌이 일어난 경우 충돌한 인덱스를 기준으로 규칙을 통해 비어있는 인덱스를 찾아 나가는 방식이다.
* 선형 조사 : 충돌이 일어난 바로 뒷 자리 값으로 넣어준다.
* 이차 조사 : 충돌시 제곱만큼 건너뛴 버킷에 저장
* 이중 해시 : 충돌시 다른 해시 함수를 한번 더 적용한 결과를 저장
* 재해싱 : 해시 테이블의 크기를 늘리고 새로운 해시 테이블의 크기에 맞춰 다시 모든 데이터를 해싱하는 방법

* 장점으로는 포인터가 필요 없고, 삽입 삭제시 오버헤드가 작다는 점이 있다. 그러나 최악의 경우에는 비어있는 버킷을 찾지 못하고 탐색한 위치로 돌아올 수도 있다. 또한 특정한 위치에 몰려있을 수 있다. 

* Closed Addressing Method 중 체이닝 방식은 해시 충돌 발생시 키에 해당하는 데이터를 연결 리스트로 만들어 해당 버킷에 추가하는 방식이다. 이는 삭제나 삽입이 간단하며 작은 데이터를 저장할 때 유용하다. 레드 블랙 트리를 사용하는 방식은 메모리 사용량이 많다.

* 자바에서는 HashTable과 HashMap 두 가지 API가 있다. HashTable은 JDK 1.0부터 사용되는 Java의 API이고, HashMap은 Java2에서 소개된 Java Collections Framework에 속한 API이다. 둘 다 Map 인터페이스를 구현하며 비슷한 기능을 제공하지만, 몇 가지 차이가 있다.

* HashMap은 보조 해시 함수를 사용하기 때문에 보조 해시 함수를 사용하지 않는 HashTable에 비하여 해시 충동이 덜 발생할 수 있어 성능상 이점이 있다. 그러나 HashMap은 동기화를 지원하지 않아 HashTable에 비해 느릴 수 있다. Java에서는 멀티스레드 환경에서 HashTable 대신 HashMap을 사용할 것을 권장한다.


### Stack & Queue
**- Stack** 
* 스택(Stack)은 나중에 삽입된 데이터가 먼저 삭제되는 후입선출(LIFO, Last In First Out) 구조를 가지며, 책을 쌓는 것처럼 데이터를 쌓아 올린 형태의 자료구조이다. 

- 삽입, 삭제 연산이 한 방향에서 이루어진다. (Top)
- 주요 활용 사례로 웹 브라우저 방문 기록, 역순 문자열 만들기, 실행 취소(undo), 후위 표기법 계산, 수식의 괄호 검사 등이 있다.

**- Queue** 
* 큐(Queue)는 선입선출(FIFO, First In First Out) 구조를 가지는 형태의 자료구조이다. 
- 데이터가 삭제될 위치를 Front / Head로, 마지막 데이터가 삽입된 위치를 Rear / Tail로 부른다.
- 주요 활용 사례로 우선순위가 같은 작업 예약, 프로세스 관리, 너비 우선 탐색(BFS), 캐시(Cache) 구현 등이 있다.


