# 정규화(Nomalization)
---
- 이상 현상이 있는 릴레이션(DB 테이블)을 분해하여 이상 현상을 없애는 과정이다
- 장점
	테이블 간에 중복된 데이터를 허용하지 않음으로써 무결성을 유지하고 저장 용량을 줄일 수 있다
	정규화를 통해 불필요한 데이터를 없앨 수 있고, 삽입/삭제/갱신 시 발생할 수 있는 각종 이상 현상을 방지할 수 있다
- 단점
	릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산이 많아진다
- 제 1 정규화 : 테이블의 **컬럼이 원자값(하나의 값)** 을 갖도록 분해하는 것 
- 제 2 정규화 : 제 1 정규화가 진행된 테이블에 대해 **완전 함수 종속(기본 키의 부분집합이 결정자가 되어선 안된다)** 을 만족하도록 테이블 분해. 
- 제 3 정규화 : 제 2 정규화를 진행한 테이블에 대해 **이행적 종속(A->B, B->C => A->C)이 없도록** 테이블을 분해. 
- BCNF 정규화 : 제 3 정규화를 진행한 테이블에 대해 **모든 결정자(A->B를 만족하는 A)가 후보키(기본키로 사용할 수 있는 속성)가 되도록** 테이블을 분해.

- 출처
	[[CS - 데이터베이스] DB 정규화란?](https://velog.io/@dlgosla/%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%93%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8B%B5%EB%B3%80)


# 이상(Anomaly)
---
- **이상 현상**이란 **테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생하는 데이터 불일치 현상**을 말한다.
- 종류
	1. 삽입 이상 :  데이터 삽입 시 의도와 상관없는 값들이 함께 삽입되는 현상. 불필요한 정보를 함께 저장하지 않으면 어떤 정보를 저장하는 것이 불가능하다.
	1. 갱신 이상 : 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생김. 반복된 데이터 중에 일부를 수정할 경우 데이터 불일치가 발생한다.
	2. 삭제 이상 : 데이터 삭제 시 의도와 상관없는 값도 삭제되는 현상. 필요한 정보를 함께 삭제하지 않으면 어떤 정보를 삭제하는 것이 불가능하다.

- 출처
	[[CS] [면접을 위한 CS 전공지식 노트] SECTION 4.2 ERD와 정규화 과정](https://velog.io/@given53/CS-%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B8-SECTION-4.2-ERD%EC%99%80-%EC%A0%95%EA%B7%9C%ED%99%94-%EA%B3%BC%EC%A0%95)
	[신입 웹 개발자 면접 질문, 기술 면접 문제 정리(Java, Spring, JavaScript, CS, 포트폴리오)](https://minchoi0912.tistory.com/93)
	
# 인덱스(INDEX)
---
- **인덱스**란 테이블을 처음부터 끝까지 검색하는 방식인 FTS(Full Table Scan)과는 달리 **인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법**이다.
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가, 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
- **즉, 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터 검색 속도를 높이는 기능이다.**
- DBMS 의 인덱스 관리 방법
	1. **B+Tree 인덱스 자료구조** 
		- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
		- B-Tree 리프 노드들을 Linked list 로 연결하여 순차 검색을 용이하게 한다
		- 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조이다
	2. **해시 테이블**
		- 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다
		- 시간복잡도가 O(1)로 검색이 매우 빠르다
		- 부등호와 같은 연속적 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않다

- 출처
	[신입 개발자 기술면접 질문 정리 - 데이터베이스](https://dev-coco.tistory.com/158)

# 트랜잭션(Transaction)
---
- **트랜잭션**이란 **데이터베이스의 상태를 변환시키는 하나의 논리적 작업 단위를 구성하는 연산들의 집합**이다.
- **하나의 트랜잭션은 commit 되거나 rollback 된다.**
	- **commit 연산** : 트랜잭션 안의 작업 내용 반영. 
		- 한 개의 트랜잭션에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다
	- **rollback 연산** : 트랜잭션 안의 작업 내용 반영 안함. 
		- 하나의 트랜잭션 처리가 비정상적으로 종료되어 **데이터베이스의 일관성을 깨뜨렸을 때**, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 **트랜잭션이 행한 모든 연산을 취소(undo)**하는 연산이다. 
		- rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.
	
- 데이터베이스 응용프로그램은 트랜잭션들의 집합으로 정의할 수 있다.
- **트랜잭션의 성질 (ACID)**
	1. **원자성 (Atomicity)** : 트랜잭션의 모든 연산들은 정상적으로 수행 완료 되거나, 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.
	2. **일관성 (Consistency)** : 트랜잭션은 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.
	3. **독립성 (Isolation)** : 하나의 트랜잭션이 실행하는 도중 변경한 데이터는 이 트랜잭션이 완료될 때 까지 다른 트랜잭션이 참조하지 못한다.
	4. **지속성 (Durability)** : 성공적으로 수행 된 트랜잭션들은 영원히 반영되어야 한다.
- **트랜잭션의 상태**
	- 활동 (Active) : 트랜잭션이 실행 중에 있는 상태. 연산들이 정상적으로 실행 중인 상태.
	- 부분 완료 (Partially Commited) : 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
	- 완료 (Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태 
	- 장애 (Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
	- 철회 (Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

- 출처
	[03. 기술 면접 - 데이터베이스 - 트랜잭션(Transaction)](https://theheydaze.tistory.com/582)

# 트랜잭션 격리 수준(Transaction Isolation Level)
---
- **격리 수준(Isolation Level)** 이란 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준이다.
- **격리 수준의 필요성**
	- 데이터베이스는 ACID 같이 원자적이면서도 독립적인 수행을 하도록 한다.
	- 그래서 **Locking** 이라는 개념이 등장한다. ; **트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것.**
	- 하지만 무조건적인 Locking 으로 동시에 수행되는 많은 트랜잭션들을 순차적으로 처리하게 되면 DB의 성능은 떨어지게 된다.
	- 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 여지가 있다.
	- 그래서 **최대한 효율적인 Locking 방법이 필요**하다.
- **격리 수준의 종류**
	1. Read Uncommitted (레벨 0) : A 트랜잭션 중 커밋되지 않은 데이터를 B 트랜잭션에서 읽기 가능
	2. **Read Committed (레벨 1)** : A 트랜잭션이 커밋하지 않는다면 B 트랜잭션에서 A 데이터를 읽을 수 없다 (기본값). select 문장이 수행되는 동안 해당 데이터에 Shared Lock 이 걸리는 Level 
	4. Repeatable Read (레벨 2) : 트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 Shared Lock 이 걸리는 Level. 특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준. 하지만, SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다
	5. Serializable (레벨 3) : 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다
	- 격리 수준이 높아지면 데이터 부정합 문제가 발생할 확률이 줄어드는데 반해, 동시 처리 성능은 떨어진다. 
- **낮은 단계의 격리 수준 이용 시 발생하는 현상**
	1. 더티 리드 Dirty Read : 특정 트랜잭션에 의해 데이터가 변경되었지만, 아직 커밋되지 않은 상황에서, 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제
	2. 반복 불가능한 조회 Non-Repeatable Read : 같은 트랜잭션 내에서 같은 데이터를 여러 번 조회했을 때 읽어온 데이터가 다른 경우
	3. 팬텀 리드 Phantom Read : 반복 불가능한 조회의 한 종류로, 조회해온 결과의 행이 새로 생기거나 없어지는 현상 

- 출처
	[03. 기술 면접 - 데이터베이스 - 트랜잭션(Transaction)](https://theheydaze.tistory.com/582)

	[데이터베이스 트랜잭션 격리 수준과 격리 수준에 따른 문제점](https://hudi.blog/transaction-isolation-level/)

	[데이터베이스 트랜잭션 격리 수준과 격리 수준에 따른 문제점](https://hudi.blog/transaction-isolation-level/)

