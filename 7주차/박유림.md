## 정규화(Nomalization)
### 정규화란? 
- 데이터베이스의 중복을 최소화하여 저장 효율을 높이고 연산시 이상현상을 최소화할 수 있는 논리적 구조로 변환시키는 작업

### 정규화 장점? 
1. 디비의 일관성을 향상시킬 수 있다. 2. 디비 확장성을 보장할 수 있다. 3. 디비 논리적 구조를 견고하게 만들 수 있다.

### 정규화 단점?
- 정규화를 할수록 테이블의 숫자가 늘어나고 결국 Join 연산의 비용이 증가한다.

### 정규화 이론
1.     데이터 조작에 따라 릴레이션이 가지게 되는 모순성을 피하고 보다 사용자가 원하는 형태의 릴레이션을 구성하기 위한 이론
2.     정규형(보다 모순성이 적어진 릴레이션)의 개념에 기반을 둔다.
3.     어떤 릴레이션이 주어진 특정 제약조건의 집합을 만족하는지 여부에 따라 그 릴레이션이 특정 정규형에 속하는지 말할 수 있다.
4.     정규형은 상위 단계 정규형이 하위 단계 정규형을 포함한다.
5.     정규형의 규칙은 상위 단계로 가면서 필요한 제약 조건을 추가함으로서 좀 더 정규화된 형태의 정규형으로 정제된다.
![](https://i.imgur.com/gz2ITw4.png)

#### 제 1 정규형 
어떤 릴레이션 R에 속한 모든 도메인이 원자 값(atomic value)만으로 되어 있다면 제 1 정규형(1NF)에 속한다. (attribute 들이 모두 원자 값이다) => 제 1 정규형을 따라도 이상현상 있다. Ex) 지도교수가 바뀌게 되면 그 교수를 신청한 다른 학생들도 다 바꿔줘야 함 .

#### 제 2 정규형 
어떤 릴레이션 R이 1NF이고 키(기본)에 속하지 않은 애트리뷰트 모두가 기본 키에 완전 함수 종속이면, 제 2 정규형(2NF)에 속한다. (부분함수 종속을 제거하기 위해 분해하자) ex) 학과는 학번에 함수 종속이면서 지도교수를 통해 이행적 함수 종속이 되고 있다. 일반적으로 함수 종속 관계 A-> C가 존재할 때 함수 종속 관계 A->B와 B->C가 성립하면 애트리뷰트 C는 A에 이행적 함수 종속이라고 함.

#### 제 3 정규형
어떤 릴레이션 R이 2NF이고 기본 키에 속하지 않은 모든 애트리뷰트들이 기본 키에 이행적 함수 종속이 아닐 때 제 3 정규형(3NF)에 속함.

2NF -> 3NF (프로젝션) , 3NF -> 2NF(조인)

문제점 : (1) 복수의 후보 키를 가지고 있고

(2) 후보 키들이 두개 이상의 애트리뷰트들로 구성되고

(3) 후보 키의 애트리뷰트가 서로 중첩되는 경우에는 적용할 수가 없다.

#### BCNF (보이스/코드 정규형)
릴레이션 R의 결정자(determinant)가 모두 후보키(candidate key)이면 릴레이션 R은 보이스/코드 정규형에 속한다. (모든 결정자가 후보키가 되도록함) => 제3 정규형에서 일어날 수 있는 변경 이상의 문제들이 제거

#### 제 4 정규형 
릴레이션 R에 MVD A->> B를 만족하는 애트리뷰트 부분 집합 A, B가 존재할 때 R의 모든 애트리뷰트들이 이 A에 함수 종속(즉, R의 모든 애트리뷰트 X에 대해 A-> X이고 A가 후보 키)이면 릴레이션 R은 제 4 정규형에 속한다. 즉, 릴레이션 R이 BCNF에 속하고 모든 MVD가 함수 종속이면 릴레이션 R은 4NF에 속한다

다치 종속(MVD : Multivalued Dependency) : A가 결정이 되면 결정이 되는 B가 여러 개 이다. Ex ) 각 과목 당 교재 여러 개

#### 제 5 정규형
릴레이션 R에 존재하는 모든 조인 종속(JD)이 릴레이션 R의 후보 키를 통해서만 만족된다면 릴레이션 R은 제 5 정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다. Join했을 때 원래 것이 나오는 것임. => 주어진 릴레이션에서 모든 조인 종속과 모든 후보 키를 알면 그 릴레이션이 5NF에 속하는지를 결정할 수 있다. 즉, 제 5 정규형에 속하는 릴레이션은 프로젝션이나 조인으로 해결될 수 있는 이상 문제를 퐇마하고 있지는 않다는 것이 보장.

조인 종속 : 릴레이션이 그의 어떤 프로젝션들을 조인한 결과와 똑같아야 한다고 할 때 이런 제약조건을 조인 종속이라고 한다.
## 이상(Anomaly)
### 정규화가 되지 않는 논리적 구조의 이상 현상
1.     이상(anomaly) 현상 : 정규화가 되지 않은 논리적 구조로 구축된 DB의 연산시에 발생하는 문제점
2.     삭제 이상 : 한 개의 튜플을 삭제할 경우 유지해야 하는 정보까지 상실하는 정보의 손실이 일어나는 현상
3.     삽입 이상 : 어떤 정보를 테이블에 삽입하고자 할 때 불필요한 정보까지도 삽입해야 하는 경우
4.     갱신 이상 : 중복된 튜플들 중에 일부만 갱신함으로써 정보의 불일치성이 발생하게 되는 현상

## 인덱스(INDEX)
- 인덱스는 책의 맨 처음 또는 맨 마지막에 있는 색인.

- 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호다.

- DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.

- 색인이 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 다 뒤지는 Table Scan이 발생한다. 대부분의 관게형 데이터베이스에서는 기본키에 대해서 자동적으로 기본 인덱스를 생성하고 있다.

- DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.

- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### 꼬리질문1 Index의 자료구조는 어떤 것이 있나요?

1. **B+-Tree 인덱스 알고리즘**
![](https://i.imgur.com/rPvJqoD.png)

일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.

- **모든 key, data가 리프노드**에 모여있습니다. B트리는 리프노드가 아닌 각자 key마다 data를 가진다면, B+트리는 리프 노드에 모든 data를 가집니다.
- **모든 리프노드가 연결리스트**의 형태를 띄고 있습니다. B트리는 옆에있는 리프노드를 검사할 때, 다시 루트노드부터 검사해야 한다면, B+트리는 리프노드에서 선형검사를 수행할 수 있어 시간복잡도가 굉장히 줄어듭니다.
- **리프노드의 부모 key는 리프노드의 첫번째 key보다 작거나 같습니다.** 그림의 B+트리는 리프노드의 key들을 트리가 가지고 있는 경우여서, data 삽입 또는 삭제가 일어날 때 트리의 key에 변경이 일어납니다. 해당 경우뿐만 아니라 data의 삽입과 삭제가 일어날 때 트리의 key에 변경이 일어나지 않게 하여 더욱 편하게 B+트리를 구현하는 방법도 존재하기 때문에 **작거나 같다**라는 표현을 사용하였습니다.

2. Hash 인덱스 알고리즘

칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### 꼬리질문2 그렇다면 왜 index를 생성하는데 b- tree를 사용하나요?

데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다.

### 꼬리질문3 Index의 성능을 위해 고려해야할 사항에는 어떤 것들이 있나요?

조회 시 자주 사용하고, 고유한 값

- 카디널리티 (Cardinality)
- 선택도 (Selectivity)
- 활용도
- 중복도

4가지의 기준이 있을 수 있다.

1. 카디널리티

**카디널리티가 높을 수록 인덱스 설정에 좋은 컬럼.**

= 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋다.

2. 선택도

선택도가 낮을수록 인덱스 설정에 좋은 칼럼

데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표.

선택도는 아래와 같이 계산

> = 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100
> 
> = 컬럼의 값들의 평균 row 수 / 테이블의 총 row 수 * 100

3. 활용도

해당 칼럼이 실제 작업에서 얼마나 활용되는지에 대한 값.

활용도가 높을수록 인덱스 설정에 좋은 칼럼이다.

4. 중복도

같은 컬럼에 대해 인덱스가 중복으로 생성된 경우를 볼 수 있는데 이러한 중복 인덱스가 없을수록 인덱스 설정에 좋은 칼럼이다.

### 꼬리질문4 Secondary Index에 대해서 알고 있나요?

기본키에 Index를 거는 것 외에 추가적으로 다른 필드에 인덱스를 거는 것을 보조 인덱스라고 한다.

보조 인덱스가 늘어나면 늘어날수록 인덱스의 크기가 커지고 파일을 찾는데도 시간이 오래 걸릴 수 있기 때문에 유의하여 사용해야 한다.
## 트랜잭션(Transaction)
- `Transaction`: 쪼개질 수 없는 업무처리의 단위
- `commit`: 모든 부분 작업이 정상적으로 완료되면 이 변경사항을 한번에 DB에 반영
- `rollback`: 부분 작업이 실패하면 **트랜잭션 실행 전**으로 되돌림

### 트랜잭션의 개념
- DB 상태를 변환시키는 **하나의 논리적 기능**을 수행하기 위한 작업의 단위
- DB 시스템에서 복구 및 병행 수행 시 처리되는 작업의 논리적 단위
- 한꺼번에 수행되어야 하는 일련의 연산

### 특징 (ACID)
- **원자성(Atomicity)**: 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.
    - 데이터베이스에서 원자성을 보장하기 위해 `트랜잭션 로그`를 사용하여 구현됩니다. 작업이 실패하면 로그에 기록된 내용을 사용하여 이전 상태로 롤백합니다.
- **일관성(Consistency)**: 트랜잭션의 작업 처리 결과는 항상 일관성을 가져야 한다.
    - 일관성을 유지하기 위한 전략으로는 무결성 제약 조건, 트리거, 저장 프로시저 등이 있습니다.
- **독립성(Isolation)**: 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. (하나의 특정 트랜잭션이 완료될 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.)
    - 격리 수준에는 Read Uncommitted, Read Committed, Repeatable Read, Serializable 등이 있습니다.
        - READ UNCOMMITTED는 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준
            - 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)
            - Non-Repeatable Read = 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라짐
            - Dirty Read는 데이터가 조회되었다가 사라지는 현상
        - READ COMMITTED는 커밋된 데이터만 조회
            - 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)
            - Non-Repeatable Read = 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라짐
        - Repeatable Read는 **트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준**
            - 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)
        - SERIALIZABLE은 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다. SERIALIZABLE에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다.
- **영속성(Durability)**: 트랜잭션이 성공적으로 완료 되었다면 결과는 영구적으로 반영되어야 한다.

### 꼬리질문1 데이터베이스에서 영속성을 보장하기 위해 어떤 메커니즘이나 기술을 사용하나요?

- **답변**: 트랜잭션 로그와 체크포인트를 사용하여 데이터베이스의 영속성을 보장합니다. 로그를 사용하여 시스템 장애 발생 후에도 데이터를 복구할 수 있습니다.

### 꼬리질문2 트랜잭션의 중첩(Nested Transaction)에 대해 알고 있나요?

- **답변**: 중첩 트랜잭션은 큰 트랜잭션 내에서 작은 트랜잭션을 수행하는 것을 말합니다. 실패한 작은 트랜잭션은 롤백할 수 있지만, 바깥쪽의 큰 트랜잭션은 계속 실행될 수 있습니다.

## 트랜잭션 격리 수준(Transaction Isolation Level)
- Isolation Level은 동시 트랜젝션이 수행될 때 다른 트랜잭션이 동일한 데이터에 대해서 어떻게 보일지에 대한 범위를 나타낸다.(트랜잭션 격리 수준)
- 격리 수준은 여러 개의 트랜잭션이 동시에 실행될 때 서로 간섭하지 않도록 제어하는 역할
- 격리 수준을 설정함으로써 데이터베이스 트랜잭션 간의 일관성과 동시성을 관리할 수 있다.

### Isolation 관련 용어

- Dirty Read: 현재 트랜잭션에서 커밋되지 않은 변경 데이터를 다른 트랜잭션이 읽을 수 있음을 의미한다.
- Nonrepeatable Read: 가장 먼저 데이터를 읽은 데이터가, 다른 트랜잭션에서 변경을 했고, 이후 다시 데이터를 읽을때 변경된 데이트를 읽을 수 있음을 의미한다. (즉, 먼저 변경한 쪽의 데이터를 다시 읽게 됨을 의미)
- Phantom read: 다른 트랜잭션이 신규 데이터를 추가하거나, 기존 데이터를 삭제할때, 범위 쿼리를 수행하면 데이터 row가 달라지는 현상을 말한다.

### **DEFAULT**

- 기본 Isolation 은 DBMS에 설정한 isolation level을 따라간다.
- Mysql은 REPEATABLE READ 가 기본 설정이다.
- Oracle은 READ_COMMIT 이 기본 설정이다.
- SQL Server는 READ_COMMIT 이 기본 설정이다.
- Postgres는 READ_COMMIT 이 기본 설정이다.

### **READ_UNCOMMITTED Isolation**

- 가장 느슨한 isolation level이다.
- 동시에 동일 데이터에 대해서 트랜잭션이 수행되는 경우 결과를 보장하지 못하고, 계속해서 커밋되지 않은 값을 읽을 수 있게 된다.
- Dirty Read, Non-Repeatable Read, Phantom Read 현상이 모두 발생한다.

```
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void writeData(Data data) {...}
```

### **READ_COMMITTED Isolation**

- Dirty Read가 발생하지 않는다.
- 하나의 트랜잭션에서 커밋이 수행된 데이터는 다시 읽기를 하면 변경된 데이터를 읽게 된다.
- 즉, Non-Repeatable Read 현상과 Phantom Read 현상이 발생한다.

```
@Transactional(isolation = Isolation.READ_COMMITTED)
public void writeData(Data data) {...}
```

### **REPEATABLE_READ Isolation**

- Dirty Read, Non-Repeatable Read 현상이 발생하지 않는다.
- 즉, 커밋되지 않는 데이터에 대해서 어떠한 사이드 이펙트가 없다.
- 데이터를 다시 읽어도 원래 데이터를 그대로 유지하게 된다.
- 그러나 범위 검색을 수행하는 경우 새로 추가된 데이터나, 삭제된 데이터가 보이게 된다.
- 즉, Phantom Read현상이 발생한다.

```
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void writeData(Data data) {...}
```


### **SERIALIZABLE Isolation**

- 이는 가장 엄격한 isolation level이다.
- 동시성에 관련된 사이드 이펙트는 없다. 그러나 성능이 매우 떨어지게 된다. 왜냐하면 동시에 들어온 트랜잭션은 모두 serialize되어 순차적으로 수행되어야 하기 때문이다.

```
@Transactional(isolation = Isolation.SERIALIZABLE)
public void writeData(Data data) {...}
```

### 꼬리 질문1 각 고립 수준에서 발생할 수 있는 문제에 대해서 설명해주세요

1. **Dirty Read (더티 리드):**
    - Dirty Read는 한 트랜잭션이 다른 트랜잭션이 아직 커밋되지 않은(uncommitted) 데이터를 읽는 현상을 나타냅니다. 다시 말해, 트랜잭션이 데이터를 수정한 후에 아직 커밋되지 않은 상태에서, 다른 트랜잭션이 해당 데이터를 읽을 수 있는 상황입니다.
    - Dirty Read는 데이터 일관성 문제를 야기할 수 있으며, 트랜잭션의 롤백이 발생하면 커밋되지 않은 데이터가 사라져서 문제가 발생할 수 있습니다.
2. **Non-Repeatable Read (비반복 읽기):**
    - Non-Repeatable Read는 한 트랜잭션이 같은 데이터를 두 번 읽을 때, 그 값이 다르게 나타나는 현상을 말합니다. 다른 트랜잭션이 동일한 데이터를 수정하고 커밋할 때 발생할 수 있습니다.
    - 예를 들어, 트랜잭션 A가 데이터를 읽고, 트랜잭션 B가 해당 데이터를 수정하고 커밋하면, 이후에 트랜잭션 A가 같은 데이터를 다시 읽으면 값이 변경되어 있을 수 있습니다.
3. **Phantom Read (팬텀 리드):**
    - Phantom Read는 한 트랜잭션이 같은 쿼리를 두 번 실행할 때, 결과 집합이 다르게 나타나는 현상을 나타냅니다. 다른 트랜잭션이 데이터를 추가 또는 삭제할 때 발생할 수 있습니다.
    - 예를 들어, 트랜잭션 A가 특정 범위의 데이터를 쿼리하고, 트랜잭션 B가 데이터를 추가하면, 트랜잭션 A가 같은 쿼리를 다시 실행하면 결과 집합에 추가된 데이터가 포함될 수 있습니다.

### **꼬리질문2 고립 수준을 높이면 데이터베이스의 성능에 어떤 영향을 미칠 수 있나요?**

- 고립 수준을 높이면 데이터베이스에서 동시성 제어를 위해 더 많은 락(잠금)을 사용하게 됩니다. 이로 인해 동시에 여러 트랜잭션이 데이터를 읽거나 쓰려고 할 때 대기해야 할 가능성이 높아집니다. 고립 수준을 높이면 동시성이 줄어들어 성능 저하가 발생할 수 있습니다. 따라서 성능과 고립 수준 사이에는 트레이드오프가 존재하며, 적절한 고립 수준을 선택해야 합니다.
