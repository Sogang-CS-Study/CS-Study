## - 객체 지향 프로그래밍(OOP)

### 객체지향 언어의 특징
- **클래스와 인스턴스** (객체)
    - 클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 **변수**와 **메서드**로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다.
    - 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터
- **추상화** : 클래스를 설계하는 것 자체, 즉 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- **캡슐화** : 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 외부로 부터 보호하는 것입니다.
    - 목적 2가지
        1. 코드를 재수정 없이 재활용하는 것.
        2. 접근 제어자를 통한 정보 은닉
    - 이를 통해 객체의 고유 독립성과 책임 영역을 안전하게 지키고자 하는 목적이 있습니다.
- **상속** : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것
- **다형성**: 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것
    - 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
    - 오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.
    - 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

### 객체 지향 설계의 5원칙
**SOLID** 원칙이란 객체지향 설계에서 지켜줘야 할 5개의 소프트웨어 개발 원칙( **S**RP, **O**CP, **L**SP, **I**SP, **D**IP )을 말한다.

- **S**RP(Single Responsibility Principle): 단일 책임 원칙
- **O**CP(Open Closed Priciple): 개방 폐쇄 원칙
- **L**SP(Listov Substitution Priciple): 리스코프 치환 원칙
- **I**SP(Interface Segregation Principle): 인터페이스 분리 원칙
- **D**IP(Dependency Inversion Principle): 의존 역전 원칙

객체지향 프로그래밍의 핵심 원칙 중 하나는 "객체는 가능한 한 자기 자신을 스스로 관리하며, 외부와는 가능한 한 독립적으로 동작해야 한다"입니다. 하지만 실제로 객체는 다른 객체와 상호작용을 해야 하며, 이 때 의존성이 발생합니다.

이를 해결할 수 있는 것인 DI(Dependency Injection, 의존성 주입)는 객체지향 프로그래밍에서 중요한 설계 패턴 중 하나입니다. 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것.

이로 인해 객체 간의 의존성을 줄이고 재사용을 용이하게 하여 객체지향 프로그래밍의 장점을 살릴 수 있다.

### **객체지향과 DI의 연결고리**

1. **단일 책임 원칙(Single Responsibility Principle)**: 객체가 하나의 책임만을 가져야 한다는 원칙을 DI는 잘 지킵니다. 예를 들어, 데이터베이스 연결을 관리하는 객체는 로직 처리를 담당하는 객체와 분리됩니다. 이렇게 하면 각 객체는 자신의 책임에만 집중할 수 있습니다.
    
2. **개방-폐쇄 원칙(Open/Closed Principle)**: DI를 통해 구현된 클래스는 확장에는 열려 있고, 수정에는 닫혀 있다. 즉, 새로운 기능 추가나 변경이 필요할 때 기존 코드를 수정하지 않고도 확장이 가능합니다.
    
    가장 일반적인 방법 중 하나는 다형성(Polymorphism)과 인터페이스(Interface)를 사용하는 것입니다. 예를 들어, 주문 로직의 경우 Order라는 인터페이스를 만들고 주문에 할인된 주문이 있고 정상 주문도 있으므로 이를 각각 구현하는 구체 클래스를 만듭니다. 이때, Order 인터페이스 안에 있는 process 메소드를 오버라이딩하여 각각 구체적인 프로세스에 맞게 정의합니다. 이렇게 구현하면 주문을 진행하는 클라이언트 코드에서 Order 객체를 주입받는다면 이를 구현한 구체 클래스들이 다형성으로 통해 다 전달 가능하게 되므로 어떤 종류의 주문이든 받아서 기존 코드 수정 없이 처리할 수 있으므로 구현할 수 있습니다.
    
    ```jsx
    public interface Order {
        void process();
    }
    ```
    
    ```jsx
    public class DiscountOrder implements Order {
        @Override
        public void process() {
            // 할인 주문 처리 로직
        }
    }
    ```
    
    ```jsx
    public class OrderProcessor {
        public void processOrder(Order order) {
            order.process(); // 다형성을 통한 주문 처리
        }
    }
    ```
    
3. **의존 역전 원칙(Dependency Inversion Principle)**: 이 원칙은 의존성을 역전시켜, 상위 모듈이 하위 모듈에 의존하지 않도록 만듭니다. DI는 이 원칙을 구현하며, 인터페이스나 추상 클래스를 통해 의존성을 역전시킵니다.
    
4. **인터페이스 분리 원칙(Interface Segregation Principle)**: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 됩니다. DI는 이 원칙을 따르는데, 클라이언트가 필요한 인터페이스만 구현한 클래스의 인스턴스를 주입받을 수 있기 때문입니다. 이렇게 하면 불필요한 의존성을 피하고 더 효율적인 코드를 작성할 수 있습니다.
    
5. **리스코프 치환 원칙(Liskov Substitution Principle)**:이 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체할 수 있어 DI는 이 원칙을 지원할 수 있습니다. 상위 클래스의 인스턴스를 주입하고, 이를 통해 하위 클래스의 객체를 사용할 수 있습니다.

### 객체지향언어의 장단점
#### 장점
 - 코드의 재사용성이 높아 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
 - 코드의 관리가 용이하여 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
 - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

#### 단점
- 대형 시스템의 경우 상속 구조나 객체 간의 상호 작용이 너무 복잡해질 수 있다.
- 서브 시스템의 정의 방법이 제대로 성립되지 않앗다.
=> 관점지향 프로그래밍의 등장 (AOP)

## 디도스, 피싱, 스미싱
1. **디도스 (DDoS - Distributed Denial of Service):**
   - **정의:** 디도스 공격은 여러 대의 컴퓨터 또는 기기를 사용하여 특정 웹사이트, 서버, 네트워크, 또는 온라인 서비스를 공격하는 것입니다.
   - **동작 원리:** 공격자는 대규모의 컴퓨터 또는 봇넷(botnet)을 구축하고, 이를 이용하여 대상 시스템에 동시에 수많은 요청을 보냄으로써 해당 시스템을 다운시키거나 사용 불가능하게 만듭니다.

### DOS와 DDOS의 차이
#### dos? 
먼저 Dos(Denial of Service attack, 서비스 거부공격)를 알아봅시다. Dos는 악의적으로 특정서버 시스템을 마비시키는 겁니다. 특정 서버에 수 많은 접속 시도를 하게 하고, 따라서 다른 사용자가 정상적으로 사용하지 못하게 하는 것이죠.

버스에 타려고 하는데 이미 만원이라 다른 사람들이 타지 못하는 것과 같은 겁니다. (단, 버스안의 사람들은 악의적인 게 아니지만요.)
#### ddos?(Distributed denial of Service attack)
DDOS공격은 분산 서비스 거부공격이며 해커 또는 크래커가 감염시킨 다량의 PC서버를 이용해 특정 서버로 접속을 시도하는 공격

2. **피싱 (Phishing):**
   - **정의:** 피싱은 사칭된 웹사이트나 이메일을 사용하여 사용자들을 속여 개인 정보나 민감한 정보를 탈취하는 공격 기법입니다.
   - **동작 원리:** 피싱 공격자는 흔히 은행, 소셜 미디어, 이메일 등을 가장하는 가짜 웹사이트나 이메일을 생성하여 사용자에게 정상적인 것처럼 속이고, 개인 정보를 입력하도록 유도합니다.

3. **스미싱 (Smishing):**
   - **정의:** 스미싱은 문자 메시지(SMS)를 이용하여 사용자를 속여 개인 정보를 탈취하거나 악성 링크를 열도록 하는 공격입니다.
   - **동작 원리:** 스미싱 공격자는 사용자에게 알림 메시지를 보내거나 상황에 맞는 메시지를 전송하여, 사용자를 특정한 동작을 취하도록 유도하거나 악성 링크를 클릭하게 만듭니다.

## Hash vs Encryption
### 해시 알고리즘
암호화 기술에서 해시(hash) 알고리즘은 핵심 기술에 속한다. 해쉬 알고리즘은 임의의 길이를 가지고 있는 메시지를 받아들여 고정된 길이의 출력 값으로 바꾸어주는 함수로서, 이 때 출력 값을 해시 값(hash value) 혹은 메시지 다이제스트(message digest)라고 부른다.

해시 알고리즘을 사용하면 같은 해시 값을 갖는 두 개의 다른 입력 메시지를 찾아내기란 불가능하므로 하나의 해시 값을 가지고 원래의 입력된 메시지를 예측할 수가 없게 된다.  

따라서 데이터 전송 도중에 송신자 외의 제3자에 의해서 데이터가 변조되었는지를 쉽게 파악할 수 있게 되어 전자서명 등에 유용하게 사용. 이런 성격 때문에 해시 알고리즘을 일방향(one-way) 해시 알고리즘이라고도 부른다. 

  대표적인 해시 알고리즘으로는 MD4(Message Digest 4), MD5(Message Digest 5), SHA(Secure Hash Algorithm)-1등이 있습니다. MD4나 MD5의 경우 해시 값으로 128비트를 사용하며, SHA-1의 경우 160비트를 사용한다

### 암호화 알고리즘

대칭형 암호 알고리즘, 비대칭형 암호 알고리즘 (공개키 암호 알고리즘)

### 대칭형 알고리즘 vs 비대칭형 알고리즘
대칭키 암호(Symmetric Key Cryptography)는 공유키 암호(Shared Key Cryptography)라고도 부르는데, 두 사람이 암호화와 복호화에 같은 키를 사용하는 방법이다. 공개키 암호(Public Key Cryptography)에서는 암호화할 때는 공개키(Public Key)를, 복호화할 때는 비밀키(Private Key)를 사용한다. 대칭키 암호는 공개키 암호에 비해 훨씬 더 빠르다는 장점을 가진다. 그리고 일반적으로 구현하기도 쉽고, 특허가 걸린 알고리즘을 쓰지 않아도 될 가능성이 높고, 프로세싱 파워가 약해도 처리하기가 쉽다. 하지만 메시지를 주고받는 당사자가 같은 키를 가지고 있어야 하는데, 이 방법은 불편하기도  하고 상황에 따라 불가능할 수도 있다. 양쪽 당사자가 지리적으로 멀리 떨어져 있을 때 한쪽이 다른 쪽에 키를 알려주려면 보안이 유지되는 통신 방법이 필요하다. 하지만 순수한 대칭키 암호 시나리오에서는 보안이 갖춰진 통신을 일반적으로 사용할 수가 없다. 만약 그런게 있었다면 암호화를 통해 별도의 보안 채널을 만들 필요도 없었을 것이기 때문이다.

공개키 암호 방식에서는 암호화하는데 사용한 공개키가 공개된다고 하더라도 암호화된 메시지는 안전하게 유지된다. 즉, 공개키를 보안이 갖춰지지 않은 채널을 통해 전송해도 안전하다. 공개키 암호를 써서 공유 세션 키를 구축하고, 공유 세션 키를 써서 대칭키 암호를 통해 통신하는 경우를 종종 볼 수 있다. 이 방법을 쓰면 공개키 암호의 편리함과 공유키 암호의 성능을 동시에 누릴 수 있다.

공개키 암호와 대칭키 암호 모두 웹에서 정보를 보호하기 위한 용도로 쓰인다. 우선 공개키 암호를 써서 웹 브라우저와 웹 사이트간에 공유 세션 키를 구축한다. 그러고 나서 개인 정보를 획득할 때는 대칭키 암호를 써서 웹 사이트와 데이터를 주고받게 된다.
