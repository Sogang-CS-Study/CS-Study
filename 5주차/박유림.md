1. [CPU 스케줄링](#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
	1. [FCFS (First Come First Served) 스케줄링](#fcfs-first-come-first-served-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
	1. [SJF(Shortest-Job-First) 스케줄링](#sjfshortest-job-first-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
	1. [Priority 스케줄링](#priority-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
	1. [Round Robin(RR) 스케줄링](#round-robinrr-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
	1. [Multilevel Queue Scheduling](#multilevel-queue-scheduling)
	1. [Multilevel Feedback Queue Scheduling](#multilevel-feedback-queue-scheduling)
1. [캐시(Cache)란](#%EC%BA%90%EC%8B%9Ccache%EB%9E%80)
	1. [메인 메모리](#%EB%A9%94%EC%9D%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC)
	1. [Cache란?](#cache%EB%9E%80)
	1. [캐시의 성능](#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%84%B1%EB%8A%A5)
	1. [지역성](#%EC%A7%80%EC%97%AD%EC%84%B1)
	1. [꼬리질문](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8)
1. [데드락(DeadLock)](#%EB%8D%B0%EB%93%9C%EB%9D%BDdeadlock)
	1. [데드락이란?](#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80)
	1. [데드락의 발생조건](#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%98-%EB%B0%9C%EC%83%9D%EC%A1%B0%EA%B1%B4)
	1. [데드락 처리](#%EB%8D%B0%EB%93%9C%EB%9D%BD-%EC%B2%98%EB%A6%AC)
		1. [교착 상태를 예방하고, 회피한다!](#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%98%88%EB%B0%A9%ED%95%98%EA%B3%A0-%ED%9A%8C%ED%94%BC%ED%95%9C%EB%8B%A4)
		1. [교착 상태를 탐지하고 회복한다!](#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C%EB%A5%BC-%ED%83%90%EC%A7%80%ED%95%98%EA%B3%A0-%ED%9A%8C%EB%B3%B5%ED%95%9C%EB%8B%A4)
	1. [꼬리질문](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8)
1. [Race Condition](#race-condition)
	1. [Race Condition이란?](#race-condition%EC%9D%B4%EB%9E%80)
1. [세마포어(Semaphore) & 뮤텍스(Mutex)](#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore--%EB%AE%A4%ED%85%8D%EC%8A%A4mutex)
	1. [세마포어란?](#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EB%9E%80)
		1. [임계 구역(Critical Section)](#%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%ADcritical-section)
	1. [뮤텍스란?](#%EB%AE%A4%ED%85%8D%EC%8A%A4%EB%9E%80)
	1. [꼬리질문) 세마포어와 뮤텍스의 차이는?](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B8-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94)
1. [페이징 & 세그먼테이션 (PDF)](#%ED%8E%98%EC%9D%B4%EC%A7%95--%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-pdf)
	1. [세그멘테이션이란?](#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80)
	1. [페이징이란](#%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%B4%EB%9E%80)
		1. [페이지 테이블](#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94)
		1. [TLB(Translation Lookaside Buffer)](#tlbtranslation-lookaside-buffer)
	1. [세그멘테이션 vs 페이징](#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-vs-%ED%8E%98%EC%9D%B4%EC%A7%95)
	1. [꼬리질문1 페이징 또는 세그멘테이션을 사용하는 이유는?](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B81-%ED%8E%98%EC%9D%B4%EC%A7%95-%EB%98%90%EB%8A%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94)
	1. [꼬리질문2 페이징의 특징은?](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B82-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%9D%80)
	1. [꼬리질문3 페이징과 세그멘테이션의 차이는?](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B83-%ED%8E%98%EC%9D%B4%EC%A7%95%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94)
	1. [꼬리질문4 외부 단편화 vs 내부 단편화](#%EA%BC%AC%EB%A6%AC%EC%A7%88%EB%AC%B84-%EC%99%B8%EB%B6%80-%EB%8B%A8%ED%8E%B8%ED%99%94-vs-%EB%82%B4%EB%B6%80-%EB%8B%A8%ED%8E%B8%ED%99%94)
1. [페이지 교체 알고리즘](#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	1. [페이지 폴트](#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8)
	1. [1. FIFO(First In First Out) 알고리즘](#1-fifofirst-in-first-out-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	1. [2. OPT(Optimal) 알고리즘](#2-optoptimal-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	1. [3. LRU(Least Recently Used) 알고리즘](#3-lruleast-recently-used-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	1. [4. LFU(Least Frequently Used) 알고리즘](#4-lfuleast-frequently-used-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	1. [5. MFU(Most Frequently User) 알고리즘](#5-mfumost-frequently-user-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

## CPU 스케줄링
> 어떤 프로세스에 CPU를 할당할지 결정하는 작업

### FCFS (First Come First Served) 스케줄링

- 가장 먼저 요청한 프로세스에 CPU를 할당해주는 방식이다.
- 비선점형(Non-preemptive) 스케줄링이다.
- 작성이 간단하고 이해하기 쉽다.
- 평균 대기 시간(Average Waiting Time)이 길어질 수 있다.
- 응답 시간(Response Time)이 길어질 수 있다.
- 반환시간(Turnaround Time) 면에서는 좋을 수 있다.
- Convoy Effect(호위 효과)가 발생할 수 있다.
	- 먼저 도착한 프로세스가 실행되는 시간이 길면 뒤에 도착한 작업들이 일찍 끝나는 작업이여도 너무 늦게 실행 됨.

### SJF(Shortest-Job-First) 스케줄링

- 다음 CPU burst time의 길이를 고려해서 스케줄링을 결정하는 알고리즘이다.
- 비선점형과 선점형이 따로 존재한다. 
- 비선점형에서는 실행되고 있는 프로세스는 끝까지 실행한다.
- 선점형에서는 현재 실행되고 있는 프로세스의 남은 시간보다 도착한 다음 프로세스가 더 빨리 끝날 수 있는 프로세스라면 다음 프로세스를 실행하도록 바꾸게 된다. **SRTF**(Shortest Remaining Time First)라고도 부른다. 
- SJF 스케줄링은 평균 대기 시간을 줄일 수 있다.
- 하지만 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재한다.

### Priority 스케줄링

- 각각의 프로세스에 우선순위 넘버가 있다.
- 가장 높은 우선순위의 프로세스에 CPU를 할당한다.
- 선점형과 비선점형이 나뉜다.
- SJF도 Priority 스케줄링이라고 할 수 있다. ( 다음 CPU burst time이 우선순위인 것처럼 작동하므로)
- 기아(Starvation) 문제가 발생할 수 있다. 기아 문제란 낮은 우선순위의 프로세스가 절대 실행되지 않는 문제를 뜻함.
- 기아문제를 해결하기 위해서 노화(aging)를 사용할 수 있다. 시간이 지날수록 프로세스의 우선순위를 높여주는 식.

### Round Robin(RR) 스케줄링

- 각각의 프로세스에 동일한 CPU 할당 시간을 부여해서 해당 시간 동안만 CPU를 이용하게 한다.
- 할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어가므로 선점형 방식이다.
- n개의 프로세스가 있을 때 할당 시간을 q로 설정하면, 어떤 프로세스도 (n-1)q 시간 이상을 기다리지 않아도 된다.
- 응답 시간을 빠르게 할 수 있다는 장점이 있다.
- q가 커진다면 FCFS처럼 작동한다. 
- q가 매우 작아지면 process sharing이라고 부른다. 이것은 n개의 프로세스가 프로세서 속도의 1/n 씩으로 작동함을 의미한다.

### Multilevel Queue Scheduling

### Multilevel Feedback Queue Scheduling


## 캐시(Cache)란

![](https://i.imgur.com/4JHdhCL.png)

### 메인 메모리
> CPU가 직접 접근할 수 있는 기억 장치

- RAM은 Random Access Memory의 약자로, **어느 위치에 저장된 데이터든지 접근하는 데 동일한 시간이 걸리는 메모리**
- RAM은 DRAM과 SRAM이 있는데 주기억장치는 주로 DRAM을 의미

### Cache란?
> 메인 메모리에 저장된 내용의 일부를 임시로 기억해두는 기억장치
- CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위해 주기억장치에 저장된 내용의 일부를 저장

### 캐시의 성능
캐시의 성능을 측정할 때는 Hit latency와 Miss latency가 중요한 요인으로 꼽힌다.

- **Hit**  
    요청한 데이터가 캐시에 존재하는 경우이다.  
    히트가 발생해 캐싱된 데이터를 가져오는 시간이 hit latency이다.
    
- **Miss**  
    요청한 데이터가 캐시에 존재하지 않는 경우이다.  
    미스가 발생해 상위 캐시나 메인메모리에서 데이터를 가져오는 시간이 miss latency이다.
    

평균 접근시간은 **Hit latency + (Miss rate * Miss latency)**가 된다.

### 지역성

- 자주 사용하는 데이터에 대한 판단은 지역성의 원리를 따르며 지역성은 시간지역성과 공간지역성
- **시간 지역성**  
    **최근 접근한 데이터에 대해 다시 접근**하는 경향을 말한다.  
    예를 들어 반복문에서 인덱스 역할인 변수 i는 짧은 시간안에 여러 번 접근이 이뤄진다.
    
- **공간 지역성**  
    **최근 접근한 데이터의 주변 공간에 다시 접근**하는 경향을 말한다.  
    위 반복문의 경우에는 배열 arr의 각 요소를 참조하면서 가까운 메모리 공간에 연속적으로 접근하고 있다.

### 꼬리질문
- Full Associative vs Set Associative
## 데드락(DeadLock)
### 데드락이란?
- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

### 데드락의 발생조건
1. 상호 배제 (Mutual exclusion)
	- 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

 2. 점유 대기 (Hold and wait)
	- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

 3. 비선점 (No preemption)
	- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

 4. 순환 대기 (Circular wait)
	- 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.
**아래의 네 가지 조건 중 하나라도 성립하지 않도록 만든다면 교착 상태를 해결할 수 있음!**

### 데드락 처리
#### 교착 상태를 예방하고, 회피한다!
1. 예방(prevention)
	1. 교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
2. 회피(avoidance)
	1. 교착 상태 발생 시 피해나가는 방법
		1. ex) 은행원 알고리즘
	 > - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
    > - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
    > - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

#### 교착 상태를 탐지하고 회복한다!
1. 탐지(detection)
	1. 자원 할당 그래프를 통해 교착 상태를 탐지함
	2. 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
2. 회복(recovery)
	1. 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

### 꼬리질문
1. 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.
    
2. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.
    
3. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.


## Race Condition
### Race Condition이란?
- 2개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황
- Race의 뜻 그대로, 간단히 말하면 경쟁하는 상태, 즉 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황
![](https://i.imgur.com/pKR0QcV.png)


## 세마포어(Semaphore) & 뮤텍스(Mutex)
### 세마포어란?
공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

이를 위해 나온 것이 바로 **'세마포어'**

**세마포어** : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

#### 임계 구역(Critical Section)

여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

### 뮤텍스란?

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

**뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

> 상호 배제(**Mut**ual **Ex**clusion)의 약자임

**상태가 0,1로 이진 세마포어**


![](https://i.imgur.com/Zr6WM8W.png)
![](https://i.imgur.com/wXnWIbx.png)

### 꼬리질문) 세마포어와 뮤텍스의 차이는?
1. **세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없습니다.**

뮤텍스는 항상 열쇠 1개이고, 세마포어는 여러개 가질 수 있기 때문에 
세마포어의 열쇠가 1개라면 뮤텍스와 같습니다.

2. **세마포어는 파일시스템 상 파일형태로 존재, 뮤텍스는 프로세스 범위입니다.**

즉, 프로세스가 사라질 때 뮤텍스는 clean up 됩니다.
세마포어는 소유할 수 없는 반면, 뮤텍스는 소유할 수 있습니다.

3. **뮤텍스의 경우, 뮤텍스를 소유하고 있는 쓰레드가 이 뮤텍스를 해제할 수 있습니다.**

**반면, 세마포어의 경우, 세마포어를 소유하고 있지 않은 쓰레드도 이 세마포어를 해제할 수 있습니다.**
## 페이징 & 세그먼테이션 (PDF)

### 세그멘테이션이란?
![](https://i.imgur.com/99ZdgW1.png)
- 프로세스를 **논리적 내용을 기반으로 나눠서** 메모리에 배치하는 것을 의미
![](https://i.imgur.com/9G20SNk.png)
- 페이징과 비슷하게 세그먼트 테이블을 가지고 있다.
- **세그먼트의 크기는 일정하지 않기 때문에,** 테이블에 limit 정보가 추가로 들어있다
- 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 해당 프로세스는 강제 종료
### 페이징이란
![](https://i.imgur.com/U8cYfgK.png)
![](https://i.imgur.com/PJzlM7t.png)

- 물리주소 공간(Physical address)은 연속적이지 않을 수 있다(noncontiguous)
- 페이지는 모두 같은 크기를 가진다.
- 물리주소 공간을 페이지와 같은 사이즈로 나눈 것들을 프레임(Frame)이라고 한다.
- 페이지 사이즈(=프레임 사이즈)는 하드웨어에 의해 정해진다.
- 페이지의 크기는 일반적으로 2의 제곱수를 사용한다. 일반적으로 4KB(2^12) ~ 1GB(2^20) 
- **페이지 테이블(page table)을 이용해 논리주소에서 프레임을 가리키는 물리주소로 매핑한다.**
- **외부 단편화는 발생하지 않으나, 내부 단편화는 발생한다.**
- 세그먼트와 다르게 고정된 크기의 단위로 주소공간을 분할함
- 이 고정 크기의 단위를 페이지

#### 페이지 테이블
- 주소공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위하여 운영체제는 프로세스마다 페이지 테이블 ( page table ) 이라는 자료구조를 유지
- 페이지 테이블은 per-process 데이터 구조이다. 즉, 모든 프로세스가 페이지 테이블을 가지고 있다.
- 페이지 테이블은 메인 메모리에 저장된다.
- Page Table Base Register(PTBR)가 페이지 테이블을 가리키고 있다.
- Page Table Length Register(PTLR)가 페이지 테이블의 사이즈를 가리키고 있다.
- 이러한 레지스터들의 내용은 PCB에 저장되어 있다. 따라서 문맥교환(context switching)이 일어날 때 교체된다.
- 모든 data/instruction 접근은 두 번의 메모리 접근이 필요하다 -> **페이지 테이블에 접근하는 overhead가 존재한다.**
    - 한 번은 페이지 테이블 접근, 한 번은 실제 physical 메모리 접근
- 두번의 메모리를 접근해야 하는 문제는 fast-lookup hardware cache라고 불리는 associative memory 혹은 translation look-aside buffers(TLBs)를 이용해 해결할 수 있다.

#### TLB(Translation Lookaside Buffer)
자주 참조되는 VPN, PFN 을 저장하는 주소 변환 캐시.
TLB는 다른 여타의 캐시와 같이 주소 변환 정보가 대부분의 경우 캐시에 존재한다는 가정으로 만들어짐.
먼저 가상 주소 변환시, TLB에 접근하게 되고 만약 TLB에 존재하지 않는 VPN이라면 실제 페이지 테이블에 접근하여 TLB를 업데이트하고 다시 TLB에 접근하여 PFN을 찾는 과정을 거침.
보통 TLB도 사이즈의 제한이 있기 때문에 캐시 교체 정책을 사용하여 TLB 내부의 데이터를 교체하게 되는데 보통 LRU를 자주 사용하게 됨.
### 세그멘테이션 vs 페이징
- 세그멘테이션은 페이징보다 보호와 공유 면에서는 더 낫다.
- **하지만, 현재 대부분은 페이징 기법을 세그멘테이션보다 많이 사용한다.**
	- 그 이유는 세그멘테이션의 세그먼트 크기가 일정하지 않고 다양하기 때문이다. 세그먼트의 크기가 다양하기 때문에 다양한 hole이 발생해 **외부단편화**가 발생하여 메모리 낭비가 크게 된다.
### 꼬리질문1 페이징 또는 세그멘테이션을 사용하는 이유는?

### 꼬리질문2 페이징의 특징은?

### 꼬리질문3 페이징과 세그멘테이션의 차이는?

### 꼬리질문4 외부 단편화 vs 내부 단편화

## 페이지 교체 알고리즘

- 모든 페이지는 물리 메모리의 실질적인 크기 때문에 페이지를 모두 탑재하지 못함.
- 그래서 추가적인 스왑공간이라는 물리 디스크에 페이지를 저장
- 페이지들의 Present bit를 통해 해당 페이지가 실제 물리 메모리에 존재하는지, 아니면 스왑 공간에 존재하는지를 알 수 있음.
### 페이지 폴트

- 만약 요청된 페이지가 메모리에 없고, 디스크로 스왑되어 있다면 운영체제는 해당 페이지를 메모리로 스왑해옴.

- 페이지 폴트 발생시, 페이지 테이블에서 PFN과 PTE를 보고 디스크에 어느 위치에 있는지 파악하고 메모리로 탑재.

- 이 때 메모리에 빈공간이 없다면, 새로운 페이지를 위한 공간을 확보하기위해 다른 페이지들을 page out해야하며 이것을 교체라고 하며 이를 위해 페이지를 선택하는 것을 **페이지 교체 정책**이라고 함.
### 1. FIFO(First In First Out) 알고리즘
- FIFO 알고리즘은 이름 그대로 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘이다.
- 구현이 간단하지만 성능은 좋지 않은 편이다.
- 들어온 시간을 저장하거나 올라온 순서를 큐를 이용해 저장할 수 있다.
- Beladys Anomaly 현상이 발생할 수 있다.
	- Beladys Anomaly란 프레임의 개수가 많아져도 page-fault가 줄어들지 않고 늘어나는 현상을 말한다.

### 2. OPT(Optimal) 알고리즘
- OPT 알고리즘은 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘이다.
- 모든 페이지 교체 알고리즘 중 page-fault 발생이 가장 적다.
- Beladys Anomaly 현상이 발생하지 않는다.
- 프로세스가 앞으로 사용할 페이지를 미리 알아야한다.
- 실제로 구현하기 거의 불가능한 알고리즘이다.
- 실제로 사용하기 보다는 연구 목적을 위해 사용된다.

### 3. LRU(Least Recently Used) 알고리즘
- LRU 알고리즘은 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘이다.
- 최적 알고리즘과 비슷한 효과를 낼 수 있다.
- 성능이 좋은 편이다.
- 많은 운영체제가 채택하는 알고리즘이다.

### 4. LFU(Least Frequently Used) 알고리즘
- LFU 알고리즘은 참조횟수가 가장 적은 페이지를 교체하는 알고리즘이다.
- 교체 대상이 여러 개라면 가장 오랫동안 사용하지 않은 페이지를 교체한다.

### 5. MFU(Most Frequently User) 알고리즘
- MFU 알고리즘은 LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.
