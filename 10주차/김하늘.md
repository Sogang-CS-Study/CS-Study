
# 애자일 (Agile) vs 워터풀 (Waterfall)

* **워터풀 모델** 
	* 요구분석 -> 설계 -> 디자인 -> 코딩 -> 개발 순으로 순차적으로 이어진다
	* 오랜 기간 사용된 기법임
	* 단계별로 정형화된 접근 방식을 사용하기 때문에 기술적인 위험 요소가 적음
	* 하지만 실제로 간 단의 경계를 명확히 구분하고, 앞선 파트의 업무가 완전히 끝난 후 다음 단계 시작하는 것이 불가능함
	* 고객은 완성품이 나오기 전까지 요구 사항의 실체를 알기 어려움
	* 실제 개발된 화면 시각적 확인하고 나서야 수정 요청 발생 -> 기획 단계부터 수정해야 하기 때문에 일정, 비용 문제 발생

* **애자일 모델**
	* 고객과의 의사소통을 중시함
	* 특정 개발 방법론을 지칭하지 않음
	* 좋은 것을 빠르게 취하고, 낭비 없게 만드는 다양한 방법론을 통칭함
	* 경량 프로세스라고도 불림 <- Less Document-Oriented, Code-Oriented
	* 일정한 주기를 갖고 끊임없이 프로토타입 만들어 필요할 때마다 요구사항을 더하고 수정해서 커다란 소프트웨어를 개발해 나가는 방식임 

* 참고
	[워터폴 VS 애자일](https://bbmsk2.tistory.com/185)
# 디자인패턴

- 정의 : 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것
- **싱글톤 패턴** 
	- **하나의 클래스에 하나의 인스턴스만 갖는 패턴**임
	- 장점 - 인스턴스 생성 비용의 감소, 사용 쉬움
	- 단점 - 의존성이 높아짐, Test Driven Develop 시 걸림돌이 됨
- **의존성 주입**
	- 의존성 주입자 덕분에 메인 모듈은 간접적으로 의존성을 주입하게 됨 -> 메인 모듈은 하위 모듈에 대한 의존성이 떨어짐 (디커플링)
	- 장점 
		- 테스팅 쉬움, 이식 쉬움
		- 애플리케이션 방향이 일관되고, 쉽게 추론 가능
		- 모듈 간 관계 명확해짐
	* 단점
		* 복잡성이 늘어날 수 있음 ; 모듈을 분리하기 때문에 클래스의 수가 늘어남
	* 원칙
		* 1. 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야함
		* 2. 상위 모듈, 하위 모듈 둘 다 추상화에 의존해야 하며, 추상화는 세부 사항에 의존하면 안됨
* **팩토리 패턴**
	* 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
	* 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적 내용을 결정하는 패턴
* **전략 패턴**
	* = 정책 패턴
	* 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만든 패턴
* **옵저버 패턴**
	* 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해서 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴 
* **프록시 패턴**
	* 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞 단의 인터페이스 역할을 하는 패턴
* **이터레이터 패턴**
	* 반복자를 사용해서 컬렉션의 요소들에 접근하는 패턴 
* **MVC 패턴**
	* 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴
	* 모델 : 애플리케이션의 데이터로 DB, 상수, 변수 등을 뜻함
	* 뷰 : 사용자 인터페이스 요소
	* 컨트롤러 : 모델과 뷰를 이음


* 참고
	[[ 개발자 대화를 위한 넓고 얕은 CS 지식 ] 디자인 패턴이란?](https://velog.io/@sean2337/CS-%EB%BF%8C%EC%8B%9C%EA%B8%B0-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)