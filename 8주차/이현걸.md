## CS 스터디 8주차

### 그래프(Graph) & 트리(Tree)
**- 트리의 정의**
* "트리(Tree)"는 나무를 닮은 구조를 가지고 있는 자료구조로, 노드로 이루어진 자료구조이다. 트리는 하나의 root 노드를 가지며, 루트 노드는 0개 이상의 자식 노드를 가지고 있다. 각 자식 노드 또한 0개 이상의 자식 노드를 가질 수 있으며, 이는 반복적으로 정의된다. 노드들과 노드들을 연결하는 간선들로 구성되어 있으며, 사이클이 존재할 수 없다. 트리는 그래프의 한 종류이며, Cycle이 없는 연결 그래프 또는 DAG(Directed Acyclic Graph, 무향비순환 그래프)의 한 종류이다.

* 트리는 루트에서 어떤 노드로 가는 경로가 유일하며, 임의의 두 노드 간의 경로도 유일하다. 각 노드는 한 개의 부모 노드만을 가지며, 부모-자식 관계에 의해 데이터 흐름은 top-bottom 또는 bottom-top으로 이루어진다.

**- 트리의 용어**
* 루트 노드: 부모가 없는 노드로, 트리는 하나의 루트 노드만을 가진다. 
* 단말 노드: 자식이 없는 노드이다.
* 내부 노드: 단말 노드가 아닌 노드이다.
* 간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
* 형제(sibling): 같은 부모를 가지는 노드
* 노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
* 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
* 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
* 노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
* 트리의 차수(degree of tree): 트리의 최대 차수
* 트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이

**- 트리의 종류**
* 트리는 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등 다양한 형태로 나타낼 수 있다. 트리의 표현 방법에는 단순한 표현법, 중첩된 괄호로 표현하는 방법, 그리고 왼쪽 자식-오른쪽 형제 표현법 등이 있다.

### 힙(Heap)
**- 힙의 정의** 
* 힙(Heap)은 우선 순위 큐를 위해 만들어진 자료구조이다. 완전 이진 트리 구조를 기반으로 하며, 데이터들이 우선순위를 가진다. 이진 트리란 모든 노드의 자식의 개수가 2개 이하인 트리 구조를 얘기한다. 완전 이진 트리라는 것은 ROOT 노드부터 시작해서 자식 노드가 왼쪽부터 오른쪽 순으로 채워져 있는 트리를 얘기한다. (단, 마지막 레벨 전까지 모든 노드는 채워져 있어야 한다.) 

**- 힙의 종류**
* 힙(Heap)은 최대 힙과 최소 힙으로 구분된다.

**- 힙의 특징, 구현**
 * 힙은 데이터의 삽입과 삭제가 빠르며 각 수행시간이 O(logN)이다. 힙은 데이터 그룹을 정렬하거나 최소/최대 값을 찾을 때 사용되며, 구현은 주로 배열을 활용하고, 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.


**-힙의 연산**
* 새로운 자료가 삽입될 때 힙 구조를 만족시키기 위해서 다음과 같은 과정을 거친다. (설명을 위해서 완전 이진 트리로 구현된 최소 힙을 기준으로 하겠다)

* 힙의 삽입 연산 : 새로운 데이터를 마지막 노드에 넣는다. 부모 노드와 새로 삽입한 원소를 비교하고 (최소 힙의 경우) 자신의 값이 부모 노드보다 작다면 부모 노드와 자리를 바꾼다. 만약에 루트 노드에 도착하거나 부모 노드가 자신보다 작다면 해당 자리에서 멈춘다.

* 힙의 삭제 연산 : 루트 노드를 삭제한다. 트리의 가장 마지막 노드를 루트 자리로 삽입한다. 바꾼 위치를 노드의 힙 조건을 만족하는지 확인한다. (최소 힙의 경우, 해당 노드의 원소의 값이 자식 노드 원소의 값보다 작아야 한다) 만족하지 않는다면 자식 노드(왼쪽 자식과 오른쪽 자식 중 적합한 노드)와 키 값을 바꾼다. 자식 노드와 자리를 바꾼 후 해당 노드가 조건을 만족하거나 리프 노드에 도달할 때까지 위를 반복한다.

### 이진탐색트리(Binary Search Tree)
* 이진 탐색 트리(Binary Search Tree)는 트리 자료 구조 중에서도 이진 트리의 일종으로, binary search 알고리즘을 활용한 자료구조이며, 효율적인 탐색과 정렬 기능을 제공하는 중요한 자료구조이다. 각 노드는 특정 값(val)을 가지고 있으며, 왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 지닌 노드들로만 이루어져 있다. 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 지닌 노드들로만 이루어져 있다. 중복된 노드가 없어야 한다. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.

* BST를 순회할 때는 inorder 방식으로 순회하며, 순회를 끝내면 모든 값을 정렬된 순서로 읽을 수 있다. BST는 다음과 같이 구현된다:

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def setRoot(self, val):
        self.root = Node(val)

    def find(self, val):
        if self.findNode(self.root, val):
            return True
        return False

    def findNode(self, curNode, val):
        if curNode is None:
            return False
        elif val == curNode.val:
            return curNode
        elif val < curNode.val:
            return self.findNode(curNode.left, val)
        else:
            return self.findNode(curNode.right, val)

    def insert(self, val):
        if self.root is None:
            self.setRoot(val)
        else:
            self.insertNode(self.root, val)

    def insertNode(self, curNode, val):
        if val <= curNode.val:
            if curNode.left:
                self.insertNode(curNode.left, val)
            else:
                curNode.left = Node(val)
        else:
            if curNode.right:
                self.insertNode(curNode.right, val)
            else:
                curNode.right = Node(val)

    def traverse(self):
        return self.traverseNode(self.root)

    def traverseNode(self, curNode):
        res = []
        if curNode.left:
            res.extend(self.traverseNode(curNode.left))
        if curNode:
            res.extend([curNode.val])
        if curNode.right:
            res.extend(self.traverseNode(curNode.right))
        return res
```
코드 출처: [https://github.com/SogangSpring/NewCSStudy/blob/main/08주차/김성일.md]

* 이진 탐색 트리는 탐색, 삽입, 삭제 연산을 수행할 수 있는데, 탐색 연산은 이진 탐색 알고리즘을 활용하여 값을 찾아가는 과정이며, 시간 복잡도는 O(log n)이다. 삽입과 삭제 연산은 다양한 경우에 따라 자식의 존재 여부에 따라 다르게 처리된다.

### 트라이(Trie)
* 트라이(Trie)는 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조로, 문자열 검색에 특화된 자료구조이다. 다양한 이름으로도 불린다. "래딕스 트리(radix tree)," "접두사 트리(prefix tree)," "탐색 트리(retrieval tree)"라고도 한다. 트라이는 문자열을 검색할 때, 각 문자를 하나씩 비교하면서 효율적으로 탐색하는데 도움을 주며, 이를 통해 문자열 검색을 빠르게 할 수 있다.


**-트라이의 구현**
* 트라이의 루트 노드는 항상 공백 문자열을 나타낸다. 각 문자를 저장하는 노드는 자식 노드들을 가질 수 있다.
* 삽입 : 문자열을 삽입할 때는 각 문자마다 자식 노드를 만들며 내려가고, 이미 같은 문자가 있는 경우 해당 노드로 이동한다.  문자열이 끝나는 지점의 노드에 해당 문자열을 가리키는 데이터를 표시 및 저장한다. 
* 탐색 : 트라이를 사용하여 문자열을 탐색할 때는 가장 아래에 있는 노드부터 시작하여 문자 하나하나를 비교한다. 만약 모든 문자가 일치하면 해당 노드의 데이터가 존재한다는 것을 의미한다.
* 삭제 : ??

**-트라이의 특징과 장단점** 
* 시간 복잡도 : 최대 문자열 길이가 m인 경우에도 문자의 개수와 무관하게 시간 복잡도는 O(m)이다.

* 장점 : 문자열 검색이 빠르다. 문자열을 탐색할 때, 문자 하나하나를 모두 비교하면서 찾는 것보다 시간 복잡도 측면에서 훨씬 효율적이다. 
* 단점 : 트라이는 문자열을 저장할 때 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있어 저장 공간의 크기가 크다는 단점이 있으며, 이는 메모리 측면에서 비효율적일 수 있다.

**-참고> 다른 문자열 탐색 방법과의 비교** 
* 최대 문자열 길이를 m이라고 하고, 문자열의 개수를 n이라고 하자. naive한 방법은 문자열을 비교하는데 mn 시간이 걸린다. 이진 탐색은 문자열을 먼저 정렬하므로 시간 복잡도는 m * n * log(n)이 되지만, 이후의 문자열 비교에서는 이득을 볼 수 있다. 트라이 구조는 문자열의 개수만큼 자식 노드를 가지고, 최대 문자열 길이가 m인 경우에도 문자의 개수와 무관하게 시간 복잡도는 O(m)이다.

* 자바로 구현할 때는 TrieNode와 Trie 클래스를 사용한다. TrieNode는 자식 노드와 마지막 글자 여부를 나타내는 필드를 가지고 있으며, Trie 클래스는 루트 노드를 갖고 문자열을 삽입하고, 특정 단어가 포함되어 있는지 확인하는 기능을 제공한다.

### B-Tree & B+Tree
* 이진트리의 경우 좌우 균형이 맞지 않으면 비효율적이다. B트리는 이진 트리에서 발전되어 `삽입과 삭제시 스스로 균형을 유지`해 모든 리프노드들이 같은 레벨을 가질 수 있도록 하는 트리이다. 정렬된 순서를 보장하고, 멀티 레벨 인덱싱을 통해 빠른 검색을 할 수 있기 때문에 DB에서 사용하는 자료구조 중 하나이다.

**-B-Tree**
B-트리는 각 key마다 data를 가진다. 

* B-트리의 탐색 과정은 루트 노드부터 시작하며, key를 순회하여 일치하는 key를 찾으면 탐색을 종료한다. 루트 노드에서부터 이웃한 두 key 사이에 찾는 key가 없으면 자식 노드로 이동하고 이 과정을 반복하여 리프 노드까지 이동한다.

* 삽입 작업은 해당 위치의 리프 노드를 검색한 다음, 최대값을 초과하면 중앙값을 부모 노드로 전송하여 분할된다. 삭제 작업은 리프 노드에서 진행되며, 노드의 원소 개수에 따라 여러 경우로 나누어진다.

**-B+Tree**
* B+트리는 B-트리와 많은 면에서 유사하지만, 데이터는 반드시 리프 노드에 저장된다. 또한, 리프 노드 간에 연결이 형성되어 있으며, 모든 키와 데이터가 리프 노드에 모아져 있어 검색과정에서 리프 노드만 확인하면 되어 시간 복잡도가 개선된다.

* B+트리에서의 삽입 과정은 분할이 발생하지 않는 경우와 분할이 발생하는 경우로 나뉘며, 분할이 발생할 때는 중간값을 부모로 올리고, 오른쪽 노드에 중간값을 포함하여 분할된다. 삭제 과정은 리프 노드에서 시작하며, 리프 노드의 key 수가 최소보다 크면 키를 삭제하고, 최소인 경우 인접한 형제 노드의 키를 빌려온다. 또한, 리프 노드가 병합할 때 부모의 키를 가져오는 과정만 생략하여 왼쪽 자식과 오른쪽 자식을 병합한다.

### 정렬 알고리즘(Quick Sort, Merge Sort)
