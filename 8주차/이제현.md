### Array
데이터를 저장하는 자료구조로서 0 또는 양의 정수 index와 데이터 값으로 저장되는 구조. 배열의 index의 시작은 0이며 해당하는 index에 해당하는 데이터가 저장된다.
메모리 상에 데이터가 붙어있어 Cache Hit rate가 높다




### LinkedList
포인터와 node로 구성되어 있는 list. 포인터는 다른 LinkedList를 가리키는 데 쓰이며 node에는 데이터가 저장된다. 

응용으로는 circular linked list가 존재

q.
LinekdList의 노드 삽입 / 삭제 과정 설명

q.
Circular Linked List 내의 임의의 노드 하나가 주어졌을 때, 해당 List의 길이를 효율적으로 구하는 방법은?
-> 끝까지 쭉 가기. 공: O(1) 시: O(N)
q.
중간에 만나는 연결 리스트 A,B의 두 시작점이 주어졌을 때, 이 연결 리스트가 만나는 지점을 구하는 방법은?
-> 각각 끝까지 간다음에 각각 거리를 구하고 더 긴 쪽을 거리의 차 만큼 전진시켜놓고 만날때까지 이동. 공간복잡도 O(1), 시간복잡도 O(A+B)
q.
Circular Linked List에서 순환이 존재할때 순환을 찾는 방법은?
-> 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 출발점에서 출발시킨 뒤 만나는 지점을 찾음. 공간복잡도 O(1), 시간복잡도 O(N)

### ArrayList vs LinkedList

ArrayList: 배열과 비슷하게 index가 존재하며 index에 자료를 저장하는 형식은 같음
그렇지만 배열을 삭제, 추가하는 method가 존재함
데이터를 추가할때 용량이 더 큰 임시 배열을 만들어서 복사함.
삭제, 추가에 임시 배열을 추가해야 하기 때문에 O(N)의 시간복잡도를 가진다.
연속된 메모리 안에 저장되고 포인터를 저장할 필요가 없기 때문에 공간복잡도가 유리함.

LinkedList: 연결된 노드들의 집합인데 삽입과 삭제 연산에서 ArrayList에 비해 시간복잡도가 유리함
삭제,추가에 다음 노드를 참조하는 상태만 변경하면 되기 때문에 O(1)의 시간복잡도를 가짐.
but 데이터를 찾는데는 O(N)의 시간복잡도를 가짐

삽입과 삭제가 빈번하게 일어나는 자료에는 LinkedList를 사용하고, 검색이 빈번하게 일어나는 자료에는 ArrayList를 사용하면 될 것 같다.


### HashTable
(Key,Value)로 데이터를 저장하는, 값을 빠르게 찾을 수 있는 자료구조
저장, 삭제, 조회 -> O(1)의 시간복잡도
그러나 충돌 문제가 발생가능
충돌 회피 방법 - Chaining, Open Addressing

Chaining: Linked List를 이용하여 주소값에 구현

Open Addressing: Hash의 index에 바로 (key, value)를 작성
충돌회피법: Linear Probing. 충돌이 발생하면 다음 칸 확인. 장점: Cache Hit rate가 높음, 단점: Clustering으로 인한 성능 저하
이를 보완하기 위한 두가지 방법
Quadratic Probing
Double Hashing


### 스택(Stack) & 큐(Queue)

Stack은 FILO의 데이터 입출력 순서를 가지는 자료구조이다.


Queue는 FIFO의 데이터 입출력 순서를 가지는 자료구조이다.

emplace(args) - push와 비슷하나, 차이점은 생성자에 매개 변수를 넣어서 객체를 생성해 큐에 저장
push는 값을 복사해서 저장한다면, emplace는 객체를 생성해서 큐에 저장


### 그래프(Graph) & 트리(Tree)

정점(Vertex)과 간선(Edge)으로 이루어진 자료구조
간선은 방향성 존재가능-> 방향그래프, 무방향그래프
방향그래프: 차수(degree) 존재. indegree: 정점에 들어오는 간선의 개수 outdegree: 나가는 간선의 개수
Cycle: 임의의 한 점에서 출발해 자기 자신으로 들어올 수 있는 경로를 의미

표현법: 인접 행렬, 인접 리스트
인접행렬 -> 두 점의 연결여부를 자주 확인할 때, E가 V^2에 가까울 때 사용. 
공간복잡도: O(V^2) 정점 u,v가 연결되었는지 확인 시간복잡도: O(1), 정점 v와 연결된 모든 정점 확인 시간복잡도: O(V)

인접 리스트-> 특정 정점에 연결된 모든 정점을 자주 확인할 때, E가 V^2보다 훨씬 작을 때 사용. 공간복잡도: O(V+E), " : O(min(deg(u), deg(v))), " : O(deg(v))


### 힙(Heap)

여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위한 이진 트리.
허프만 코드 / 우선순위 큐가 힙의 구조임

최댓값 또는 최솟값은 힙의 루트노드이므로 이를 찾을때 O(1), 트리의 노드 개수가 i레벨일때 2^(i-1)개이므로 데이터의 삽입과 삭제를 O(logN)에 가능.

q. 힙트리의 삭제 / 삽입 과정?

### 이진탐색트리(Binary Search Tree)

이진트리: 각 노드의 자식이 2개 이하인 트리
이진탐색트리: 왼쪽 서브트리의 모든 값은 부모의 값보다 작고 오른쪽 서브트리의 모든 값은 부모의 값보다 큰 이진 트리
삽입,삭제,검색,수정 모두 O(logn)에 가능
q.그럼 해시가 충돌때문에 성능이 안좋아질 수는 있는데 왜 이진탐색트리를 사용함? 해시는 삽입삭제검색수정 O(1)에 가능한데?
-> 이진탐색트리는 원소가 크기 순으로 정렬되기 때문

만일 이진탐색트리에서 편향된 값이 계속 들어오면 Linked List와 다를바 없어지기 때문에 자가 균형 트리를 사용. 자가균형트리에는 AVL tree, R/B tree가 존재


### 트라이(Trie)

문자열을 효율적으로 처리하기 위한 트리 자료구조
단어 S를 삽입/탐색/삭제할 때, O(|S|)의 시간복잡도로 처리 가능. (|S| = 단어 S의 길이)
단점: 메모리를 많아 차지함. 단어들을 평범하게 배열에 저장하는것과 비교했을때 4 x ‘글자의 종류’배 만큼 더 사용
ex)알파벳 대문자: 26 *4 = 104배 더 사용
일반적인 문자열의 삽입/삭제/검색은 해시나 이진 검색 트리를 쓰는것이 메모리와 시간 측면 모두 효율적이고 구현이 쉽다.

삭제가 빈번하게 발생하는 환경에서는 트라이가 적합하지 않음
왜냐하면 트라이에서 단어를 삭제할때 점을 삭제하는것이 아니라 해당 단어가 있다는 ‘표식’만 삭제하게 되어서, 이전에 삽입한 정점들은
메모리에 계속 남아있게 되기 때문임.



### B-Tree & B+Tree
둘 모두 인덱스를 이루고 있는 자료구조의 일종
B- tree는 데이터를 리프, 브랜치노드에 모두 저장 가능, B+ tree는 데이터를 리프노드(단말 노드)에만 저장 가능
B-트리와 달리 B+트리는 linked list로 구현되었고 terminal 노드끼리 링크로 이어져있음
그렇기 때문에 데이터의 검색은 B+ tree가 리프 노드에서 선형으로 가능하여 좀 더 빠름. 
그렇지만 B- tree도 자주 사용되는 데이터를 root 노드 가까이에 배치하여 빠르게 검색 가능함

MySQL의 DB 엔진인 InnoDB는 B+ Tree로 구현됨

q) 데이터베이스에서 인덱스를 만들때 해쉬를 사용하지 않고 B+를 이용하는 이유는?
https://helloinyong.tistory.com/296

q) 그렇다면 포인터를 가진 Linked List를 사용하지 않는 이유는?



### 정렬 알고리즘(Quick Sort, Merge Sort)

Quick Sort: pivot을 놓고 pivot보다 큰 값을 오른쪽, 작은 값을 왼쪽으로 정렬한 후 다시 pivot을 놓고 base condition 즉 길이가 1이 될때까지 반복한후 이를 합치는 정렬. 장점: 구현에 추가적인 공간이 필요하지 않고 배열 안에서 자리바꿈으로 구현되기에 cache hit ratio가 높음. 시간복잡도 O(nlogn)
but 배열이 내림차순 또는 오름차순인 최악의 경우 pivot이 매번 가장 왼쪽에 위치하게되어 1+2+...+n이 되어 시간복잡도 O(n^2)

Merge Sort: 정렬할 값을 원소가 1이 될때까지 나눈 후, 나눈 값들을 정렬한 후 이를 다시 합치는 재귀적인 방식으로 정렬
합치는데 필요한 시간복잡도는 1 + 2 + ... + 2^(k-1) : O(N), 나누는데 O(nlogn), 시간복잡도는 둘중 큰 값이므로 시간복잡도는 O(nlogn)
둘다 Stable Sort
일반적으로 Merge Sort가 퀵소트보다 cache hit ration가 불리하여 같은 O(nlogn)의 시간복잡도를 가지지만 더 느림
STL을 사용 못할 때, sort를 quick sort를 구현하면 안됨. 최악의 경우 O(n^2)가 발생하기 때문.

이를 보완하기 위한 정렬 알고리즘 -> introspective sort(인트로 정렬). 퀵소트로 정렬하다가 일정 깊이 이상 들어가면 힙소트를 사용

Stable Sort: 우선 순위가 같은 원소가 여러 개일 땐 정렬한 결과가 유일하지 않을 수 있음
그 중에서 우선 순위가 같은 원소들끼리는 원래의 순서를 따라가도록 하는 정렬이 Stable Sort



