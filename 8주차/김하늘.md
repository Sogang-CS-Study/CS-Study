# ➡️Array
- **순차적으로 데이터 저장**한다
- 데이터에 순서가 있고, 0부터 시작하는 인덱스가 존재한다. 인덱스를 통해 특정 요소를 찾고 조작함이 가능하다 -> RandomAccess 가능해서 속도 빠르다 ; O(1)
- 순차적으로 존재하는 데이터의 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점이 있어서 O(n), **정보가 자주 추가되거나 삭제되는 데이터를 담기에는 적절하지 않다**
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
      


# ➡️LinkedList
- 자료의 주소 값으로 서로 연결되어 있는 구조이다. 메모리에 연속적으로 배치되지 않는
- **LinkedList 의 각 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있어 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)에 할 수 있다**
- 하지만 LinkedList 는 원하는 위치에 한 번에 접근할 수 없다 특정 원소에 접근하기 위해서는 첫 번째 원소부터 다 확인해야 한다 ; O(n) 즉, 검색이 느리다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
	[[CS/면접준비] 자료구조](https://velog.io/@bye9/CS%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)
  
# ➡️ArrayList vs LinkdedList
- Array 와는 달리 **ArrayList 는 크기가 가변적**이다. 처음 메모리 할당 시에 크기를 지정하지 않고 동적으로 값을 지정하고 삭제할 수 있다
- ArrayList 는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array 보다 느리다
- 즉, 데이터 조회에는 ArrayList 가 사용하기 적합하고, 데이터의 비순차적 삽입과 삭제에는 LinkedList 를 사용함이 적절하다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
	[ArrayList 와 LinkedList의 차이](https://dev-coco.tistory.com/19)
  
# ➡️HashTable
- 해시 테이블은 **(Key, Value)** 로 데이터를 저장하는 자료구조 중 하나로 **빠르게 데이터를 검색**할 수 있는 자료구조이다
- 빠른 검색 속도를 제공하는 이유는 **내부적으로 배열(버킷)을 사용하여 데이터를 저장**하기 때문이다
- **각 Key 값은 해시함수에 의해 고유한 index를  갖게 되어 바로 접근할 수 있으므로 평균 O(1) 의 시간 복잡도로 데이터를 조회한다**
- 하지만 index 값이 충돌이 발생한 경우 chaining 에 연결된 리스트들까지 검색해야 하므로 O(n) 까지 증가할 수 있다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
  

# ➡️스택(Stack) & 큐(Queue)
- **선형 자료구조**의 일종으로, Array 와 LinkedList 로 구현 가능하다
- **스택은 후입선출(LIFO) 방식이고, 큐는 선입선출(FIFO) 방식이다.** 
- 스택 예시 ) 자바의 Stack 메모리 영역 
- 큐 예시 ) OS의 스케줄러 ; 자원의 할당과 회수 역할 FCFS 스케줄링 정책
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
  
# ➡️그래프(Graph) & 트리(Tree)
- **그래프는 노드와 간선을 하나로 모아 놓은 구조**이다
- 무방향 그래프 / 방향 그래프 ; 정점과 간선의 연결 관계에 방향성 여부
- 차수 ; 무방향 그래프에서 각 정점에 연결된 Edge 의 개수이, 방향 그래프에서는 차수가 2개로 나뉜다
- **그래프 탐색**
	- 깊이 우선 탐색 : 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다
	- 너비 우선 탐색 : 그래프 상에 존재하는 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다 
- 트리는 정점과 간선을 이용해 **사이클을 이루지 않도록 구성한 그래프의 특수한 형태**로, 계층이 있는 데이터를 표현하기에 적합하다
- 비선형 자료구조
  
- 출처
	[[CS/면접준비] 자료구조](https://velog.io/@bye9/CS%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)
  
# ➡️힙(Heap)
- **최대값 또는 최소값을 찾아내는 연산을 쉽게 하기 위해 고안**된 구조로, 각 노드의 키 값이 자식의 키 값보다 작지 않거나(최대힙) 그 자식의 키 값보다 크지 않은(최소힙) **완전 이진 트리**이다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)

  
# ➡️이진탐색트리(Binary Search Tree)
- **이진 탐색과 연결 리스트를 결합한 자료 구조**
	- 이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 한다
- **이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료 입력과 삭제가 가능하다**
- 이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h 일 때 **시간 복잡도는 O(h)** 이며, 트리의 균형이 한 쪽으로 치우친 경우 worst case 가 되어 O(n) 의 시간 복잡도를 갖는다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)

  
# ➡️트라이(Trie)
- 문자열에서 검색을 빠르게 도와주는 트리 형태의 자료구조이다
- 문자열의 최대 길이가 M 일 때 트라이 활용 시 O(M)으로 문자열 검색이 가능하다
- 접두사 트리(Prefix tree) 라고도 한다
- 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장 공간의 크기가 크다는 단점이 있다
  
- 출처
	[[자료구조] 트라이 (Trie)](https://velog.io/@kimdukbae/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%9D%BC%EC%9D%B4-Trie)
  
# B-Tree & B+Tree
- 이진 탐색 트리의 차수는 2이기 때문에 높이가 커지게 되는 문제점이 있다. -> **M-way 검색 트리는 차수를 2 에서 m개로 늘려서** 문제점을 해결하였다
- M-way 검색 트리는 높이는 줄였지만 균형이 맞지 않다는 문제점이 있다. -> **B-Tree 는 균형을 유지한다** 따라서 아무리 최악의 경우라도 O(logn) 의 검색 성능을 보여준다
- **B 트리는 하나의 노드에 많은 정보를 가지거나, 두 개 이상의 자식을 가질 수 있다.** 최대 M개의 자식을 가질 수 있는 트리를 M차 B 트리라고 한다
- **B+트리는 B트리의 확장 개념으로, B트리와 달리 모든 노드에 key 와 data 가 잊지 않고 리프 노드에만 key, data 가 존재한다. 그리고 리프 노드들끼리는 연결 리스트로 연결되어 있다.**
- 즉, B+트리는 내부 노드들이 데이터를 갖고 있지 않고 리프 노드들이 키와 데이터를 모두 가지고 있어야 하므로, 중복 키를 갖게 된다 
  
- 출처
	[[자료구조] B트리와 B+트리](https://m.blog.naver.com/shekwl24/222245938621)
  
# ➡️정렬 알고리즘(Quick Sort, Merge Sort)
- **퀵소트**는 매우 빠른 정렬 속도를 보이는 **분할 정복 알고리즘** 중 하나이다
- 머지소트와 달리 **리스트를 비균등하게 분할**한다
- **피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할하여 정렬한다**
- 시간복잡도는 O(nlogn) 이며 리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도는 O(n^2)이 될 수도 있다
- **머지소트**는 주어진 **배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할 정복 알고리즘** 이다
- 시간복잡도는 O(nlogn) 이다
  
- 출처
	[신입 개발자 기술면접 질문 정리 - 알고리즘](https://dev-coco.tistory.com/160)
      