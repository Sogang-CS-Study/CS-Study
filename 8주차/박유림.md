## Array

### 배열이란(Array)
- 같은 타입의 변수들로 이루어짐
- 크기가 정해져있음
- 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복 허용
- 순서 있음

### 탐색에 걸리는 시간복잡도
- O(1)

### 삽입/삭제에 걸리는 시간복잡도
- O(n)

> 배열은 인덱스에 해당하는 원소를 빠르게 접근해야하거나 간단하게 데이터를 쌓고 싶을 때 사용

## LinkedList

### 연결리스트란(LinkedList)
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화

#### 연결리스트 종류
- 싱글연결리스트 : next 포인터만 가진다
- 이중연결리스트 : next 포인터와 prev 포인터를 가짐
- 원형이중연결리스트 : 이중연결리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것
### 탐색에 걸리는 시간복잡도
- O(n)

### 삽입/삭제에 걸리는 시간복잡도
- O(1)


## Array vs LinkedList
- 배열은 탐색에 빠르고 연결리스트는 삽입/삭제에 유리하다.

## HashTable
- 해시테이블은 무한에 가까운 데이터들을 유한한 개수의 해시값으로 매핑한 테이블
- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간복잡도를 가지며 unordered_map으로 구현

### 해시 값이 충돌하는 경우
- 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing)으로 해결 가능
## 스택 & 큐
### 스택(Stack)
- 가장 마지막으로 들어간 데이터가 가장 먼저나오는(LIFO, Last In First Out)을 가진 자료구조
- 삽입,삭제에는 O(1), 탐색 O(n) 이 걸린다.
- push(), pop() 함수가 사용됨
- 가장 오래전에 입력된 데이터는 bottom, 가장 최근에 입력된 데이터는 top이라고 한다.

### 큐(Queue)
- 먼저 넣은 데이터가 먼저 나오는(FIFO, First In First Out) 자료구조.
- 삽입,삭제에는 O(1), 탐색 O(n) 이 걸린다.
- Enqueue(), Dequeue() 함수가 사용됨
- 가장 오래전에 입력된 데이터를 front라고 하며 가장 최근에 입력된 데이터를 rear라고 한다.

## 그래프 & 트리
### 그래프(Graph)
- 정점과 간선으로 이루어진 자료구조

### 트리(Tree)
- 그래프의 일종
- 정점과 간선으로 이루어져있고 계층적 데이터의 집합
- 루트노드, 내부노드, 리프노드로 구성됨

#### 트리의 구성요소
- 루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
- 단말 노드(leaf node): 자식이 없는 노드, ‘말단 노드’ 또는 ‘잎 노드’라고도 부른다.
- 내부(internal) 노드: 단말 노드가 아닌 노드
- 간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
- 형제(sibling): 같은 부모를 가지는 노드
- 노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
- 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree): 트리의 최대 차수
- 트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이

## 힙
### Heap
- 이진트리 기반의 자료구조이며 최소힙과 최대힙 두 가지가 있다.
- 최대힙 : 루트노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야함. 
- 최소힙 : 최소힙에서 루트노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야함.

**Heap의 삽입**
- 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입
- 새로운 노드를 부모 노드들과 차례로 교환해서 힙의 성질을 만족 시킴
![](https://i.imgur.com/0e7joIO.png)

**Heap의 삭제**

- 최대 힙에서 최대 값은 루트 노드이므로, 루트 노드가 삭제 된다
- 삭제 된 루트 노드에는 힙의 마지막 노드를 가져온다
- 힙을 재구성한다.

![](https://i.imgur.com/DFDQqHm.png)

## 이진탐색트리

### 이진탐색트리의 문제점
- 이진탐색트리는 선형적으로 구성될 때 시간복잡도가 O(n)으로 커지는 문제점이 있음.
- 선형적으로 구성하지 않고 균형 잡힌 트리로 구성하기 위해 나온 트리로 AVL 트리와 레드 블랙 트리가 있다.

## 트라이
- `트라이(Trie)`는 **문자열을 저장하고 효율적으로 탐색하기 위한 `트리` 형태의 자료구조**이다.
- 우리가 검색할 때 볼 수 있는 **자동완성 기능, 사전 검색 등 문자열을 탐색하는데 특화되어있는 자료구조**라고 한다.
- 래딕스 트리(radix tree) or 접두사 트리(prefix tree) or 탐색 트리(retrieval tree)라고도 한다. `트라이`는 re**trie**val tree에서 나온 단어이다.
- 예를 들어 'Datastructure'라는 단어를 검색하기 위해서는 제일 먼저 'D'를 찾고, 다음에 'a', 't', ... 의 순서로 찾으면 된다. 이러한 개념을 적용한 것이 `트라이(Trie)`이다.
    
### 트라이(Trie) 장단점

- `트라이(Trie)`는 문자열 검색을 빠르게 한다.
- 문자열을 탐색할 때, 하나하나씩 전부 비교하면서 탐색을 하는 것보다 시간 복잡도 측면에서 훨씬 더 효율적이다.
- 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장 공간의 크기가 크다는 단점도 있다. (메모리 측면에서 비효율적일 수 있음!)

## B-Tree & B+Tree
- 데이터베이스의 인덱스에 사용되는 자료구조로 특이한 자료구조 중 하나
![](https://i.imgur.com/Nzxtcnz.png)
![](https://i.imgur.com/bLGXXag.png)
1. **모든 key, data가 리프노드**에 모여있습니다. B트리는 리프노드가 아닌 각자 key마다 data를 가진다면, B+트리는 리프 노드에 모든 data를 가집니다.
2. **모든 리프노드가 연결리스트**의 형태를 띄고 있습니다. B트리는 옆에있는 리프노드를 검사할 때, 다시 루트노드부터 검사해야 한다면, B+트리는 리프노드에서 선형검사를 수행할 수 있어 시간복잡도가 굉장히 줄어듭니다.
3. **리프노드의 부모 key는 리프노드의 첫번째 key보다 작거나 같습니다.** 그림의 B+트리는 리프노드의 key들을 트리가 가지고 있는 경우여서, data 삽입 또는 삭제가 일어날 때 트리의 key에 변경이 일어납니다. 해당 경우뿐만 아니라 data의 삽입과 삭제가 일어날 때 트리의 key에 변경이 일어나지 않게 하여 더욱 편하게 B+트리를 구현하는 방법도 존재하기 때문에 **작거나 같다**라는 표현을 사용하였습니다.

## 정렬 알고리즘
### 버블 정렬 (Bubble Sort):
- 최선 시간 복잡도: O(n)
- 평균 및 최악 시간 복잡도: O(n^2)
- 이웃한 두 원소를 비교하고, 만약 순서가 잘못되어 있으면 교환합니다.
- 가장 큰 (또는 작은) 원소가 맨 뒤로 이동할 때까지 이 작업을 반복합니다.
- 비효율적인 정렬 방법으로, 대규모 데이터셋에는 적합하지 않습니다.
### 선택 정렬 (Selection Sort):
- 최선, 평균 및 최악 시간 복잡도: O(n^2)
- 주어진 배열에서 가장 작은 원소를 찾아 첫 번째 위치로 이동시키고, 그 다음으로 작은 원소를 찾아 두 번째 위치로 이동시킵니다.
- 배열을 순차적으로 훑어나가는 방식으로 동작하며, 비교적 간단하지만 비효율적인 알고리즘입니다.
### 삽입 정렬 (Insertion Sort):
- 최선 시간 복잡도: O(n)
- 평균 및 최악 시간 복잡도: O(n^2)
- 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입합니다.
- 작은 배열 또는 거의 정렬된 배열에 대해서는 효율적일 수 있지만, 대규모 데이터에 대해선 성능이 저하될 수 있습니다.

### 퀵 정렬 (Quick Sort):
- 평균 시간 복잡도: O(n log n)
- 최악 시간 복잡도: O(n^2)
- 최선 시간 복잡도는 피벗 선택 방법에 따라 다를 수 있습니다.
- 분할 정복 방법을 사용하여 배열을 분할하고 정렬합니다.
- 빠른 정렬 속도를 제공하며, 대부분의 경우 효율적인 알고리즘 중 하나입니다.

### 병합 정렬 (Merge Sort):
- 최선, 평균, 최악 시간 복잡도: O(n log n)
- 분할 정복 방법을 사용하여 배열을 반으로 나눈 뒤, 재귀적으로 나뉜 부분을 정렬하고 병합합니다.
- 안정적이며 대규모 데이터셋에서도 효과적으로 작동합니다.
### 힙 정렬 (Heap Sort):
- 최선, 평균, 최악 시간 복잡도: O(n log n)
- 힙 자료구조를 사용하여 배열을 정렬합니다.
- 힙을 구성하고 최대 (또는 최소) 값을 반복적으로 추출하여 정렬합니다.

